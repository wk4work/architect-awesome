
<h1>《后端架构师技术图谱》</h1>

------

# 数据结构

## 队列
* [《java队列——queue详细分析》](https://www.cnblogs.com/lemon-flm/p/7877898.html)
	* 非阻塞队列：ConcurrentLinkedQueue(无界线程安全)，采用CAS机制（compareAndSwapObject原子操作）。
	* 阻塞队列：ArrayBlockingQueue(有界)、LinkedBlockingQueue（无界）、DelayQueue、PriorityBlockingQueue，采用锁机制；使用 ReentrantLock 锁。

* [《LinkedList、ConcurrentLinkedQueue、LinkedBlockingQueue对比分析》](https://www.cnblogs.com/mantu/p/5802393.html)

## 集合、链表、数组
* [《Java Set集合的详解》](https://blog.csdn.net/qq_33642117/article/details/52040345)
  * HashSet: 使用hashcode()&equals()进行去重
  * TreeSet: 红黑树结果; 元素实现Comparable接口保证可排序,或者传入Comparator使用容器排序(优先级更高)
* [《Java map 详解 - 用法、遍历、排序、常用API等》](https://baike.xsoftlab.net/view/250.html)
  * Iterator效率比for更高, enteySet效率比keySet效率更高

* [《Java集合详解--什么是List》](https://blog.csdn.net/wz249863091/article/details/52853360)
  * 数据结构: ArrayList(数组),LinkedList(双向链表)

## 栈
* [《java数据结构与算法之栈（Stack）设计与实现》](https://blog.csdn.net/javazejian/article/details/53362993)
  * 数据结构: 有序特殊的线性表,只允许单端(栈顶)操作,先进后出/后进先出
  * 使用场景: 计算器符号匹配,中缀表达式=>后缀表达式
* [《java stack的详细实现分析》](https://blog.csdn.net/f2006116/article/details/51375225)
	* Vector的子类
	* Stack 是线程安全的。
	* 内部使用数组保存数据，不够时翻倍。

## 树

### 二叉树

每个节点最多有两个叶子节点。
*  [《二叉树》](https://blog.csdn.net/cai2016/article/details/52589952)

* [《完全二叉树》](https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin)
	* 叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。
* [《浅谈算法和数据结构: 七 二叉查找树》](https://blog.csdn.net/lsx991947534/article/details/44679437)
  * 左节点小于父节点小于右节点
  * 左树节点全部小于父节点,右树节点全部大于父节点

* [《浅谈数据结构-平衡二叉树》](https://blog.csdn.net/m0_37477061/article/details/80864876)
  * 为了解决二叉树退化为链表的场景(查询效率降低至N),需要额外的旋转算法,最坏效率logN
  * 左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。
* [《浅谈算法和数据结构: 八 平衡查找树之2-3树》](https://blog.csdn.net/li1669852599/article/details/108453600)


### 红黑树
* [《最容易懂得红黑树》](https://blog.csdn.net/sun_tttt/article/details/65445754)
	* 目的是为了降低完美平衡二叉树因写入导致的平衡代价过高问题，在对数时间内完成查找
	* 添加阶段后，左旋或者右旋从而再次达到平衡。 
* [《浅谈算法和数据结构: 九 平衡查找树之红黑树》](http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html)

### B，B+，B*树
MySQL是基于B+树聚集索引组织表

* [《B-树，B+树，B\*树详解》](https://blog.csdn.net/aqzwss/article/details/53074186)
  * B树(-为连接符): 多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点; 所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中
  * B+树: 在B树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中
  * B*树: 在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3
* [《B-树，B+树与B\*树的优缺点比较》](https://blog.csdn.net/bigtree_3721/article/details/73632405)
  * B树成功查询效率更高(指非叶节点)
  * B+树的叶子节点链表结构相比于 B-树便于扫库，和范围检索。
  * B\*树分配新结点的概率比B+树要低，空间使用率更高
### LSM 树

LSM（Log-Structured Merge-Trees）和 B+ 树相比，是牺牲了部分读的性能来换取写的性能(通过批量写入)，实现读写之间的平衡。
Hbase、LevelDB、Tair（Long DB）、nessDB 采用 LSM 树的结构。LSM可以快速建立索引。

* [《LSM树 VS B+树》](https://blog.csdn.net/dbanote/article/details/8897599)
	* B+ 树读性能好，但由于需要有序结构，当key比较分散时，磁盘寻道频繁，造成写性能较差。
	* LSM 是将一个大树拆分成N棵小树，先写到内存（无寻道问题，性能高），在内存中构建一颗有序小树（有序树），随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历（二分查找）所有的小树，但在每颗小树内部数据是有序的。
	
* [《LSM树（Log-Structured Merge Tree）存储引擎》](https://blog.csdn.net/u014774781/article/details/52105708)
	* 极端的说，基于LSM树实现的HBase的写性能比MySQL高了一个数量级，读性能低了一个数量级。
	* 优化方式：Bloom filter 替代二分查找；compact 小数位大树，提高查询性能。
	* Hbase 中，内存中达到一定阈值后，整体flush到磁盘上、形成一个文件（B+树），HDFS不支持update操作，所以Hbase做整体flush而不是merge update。flush到磁盘上的小树，定期会合并成一个大树。
* [《HBase/TiDB都在用的数据结构：LSM Tree》](https://mp.weixin.qq.com/s/qxl_gQ4pWvcv3PbSqhCHIw)

## BitSet

经常用于大规模数据的排重检查。

* [《Java Bitset类》](http://www.runoob.com/java/java-bitset-class.html)
* [《Java BitSet（位集）》](https://blog.csdn.net/caiandyong/article/details/51581160)

# 常用算法

* [《常见排序算法及对应的时间复杂度和空间复杂度》](https://blog.csdn.net/gane_cheng/article/details/52652705)
* [算法可视化网站VisuAlgo](https://visualgo.net/zh)

## 排序、查找算法

* [《常见排序算法及对应的时间复杂度和空间复杂度》](https://blog.csdn.net/gane_cheng/article/details/52652705)
  * 时间O(n^2)：直接插入，希尔，选择，冒泡；O(log2n)：堆，快速，归并；常数级：基数
  * 空间O(log2n)：快速；O(n)：堆，基数；其他O(1)
  * 稳定性：直接插入，冒泡，归并，基数
* [《十种常见排序算法的思想、应用场景》](https://blog.csdn.net/Hairy_Monsters/article/details/80154391)
  * 数量小：选择排序，冒泡、插入、希尔排序（基本有序）
  * 数量大：快速排序（随机分布），堆排序（流式数据输入），归并排序（稳定）
  * 特殊要求：计数排序（非负数），基数排序（位数一致且数字），桶排序（数据均匀分布）

### 选择排序
* [《Java中的经典算法之选择排序（SelectionSort）》](https://www.cnblogs.com/shen-hua/p/5424059.html)
	* 每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。

### 冒泡排序
* [《冒泡排序的2种写法》](https://blog.csdn.net/shuaizai88/article/details/73250615)
	* 相邻元素前后交换、把最大的排到最后。
	* 时间复杂度 O(n²) 

### 插入排序
* [《排序算法总结之插入排序》](https://www.cnblogs.com/hapjin/p/5517667.html)

### 快速排序
* [《坐在马桶上看算法：快速排序》](https://blog.csdn.net/afjaklsdflka/article/details/52829030)
	* 一侧比另外一侧都大或小。 
### 归并排序
* [《图解排序算法(四)之归并排序》](http://www.cnblogs.com/chengxiao/p/6194356.html)
	* 分而治之，分成小份排序，在合并(重建一个新空间进行复制)。 

### 希尔排序
TODO

### 堆排序
* [《图解排序算法(三)之堆排序》](https://www.cnblogs.com/chengxiao/p/6129630.html)
	* 排序过程就是构建最大堆的过程，最大堆：每个结点的值都大于或等于其左右孩子结点的值，堆顶元素是最大值。

### 计数排序
* [《计数排序和桶排序》](https://www.cnblogs.com/suvllian/p/5495780.html)
	* 和桶排序过程比较像，差别在于桶的数量。

### 桶排序
* [《【啊哈！算法】最快最简单的排序——桶排序》](http://blog.51cto.com/ahalei/1362789)
* [《排序算法（三）：计数排序与桶排序》](https://blog.csdn.net/sunjinshengli/article/details/70738527)
	* 桶排序将[0,1)区间划分为n个相同的大小的子区间，这些子区间被称为桶。
	* 每个桶单独进行排序，然后再遍历每个桶。

### 基数排序

按照个位、十位、百位、...依次来排。

* [《排序算法系列：基数排序》](https://blog.csdn.net/lemon_tree12138/article/details/51695211)
* [《基数排序》](https://www.cnblogs.com/skywang12345/p/3603669.html)


### 二分查找
* [《二分查找(java实现)》](https://www.cnblogs.com/coderising/p/5708632.html)
	* 要求待查找的序列有序。
	* 时间复杂度 O(logN)。

* [《java实现二分查找-两种方式》](https://blog.csdn.net/maoyuanming0806/article/details/78176957)
	* while + 递归。
### Java 中的排序工具
* [《Arrays.sort和Collections.sort实现原理解析》](https://blog.csdn.net/u011410529/article/details/56668545?locationnum=6&fps=1)
	* Collections.sort算法调用的是合并排序。
	* Arrays.sort() 采用了2种排序算法 -- 基本类型数据使用快速排序法，对象数组使用归并排序。

## 布隆过滤器

常用于大数据的排重，比如email，url 等。
核心原理：将每条数据通过计算产生一个指纹（一个字节或多个字节，但一定比原始数据要少很多），其中每一位都是通过随机计算获得，在将指纹映射到一个大的按位存储的空间中。注意：会有一定的错误率。
优点：空间和时间效率都很高。
缺点：随着存入的元素数量增加，误算率随之增加。

* [《布隆过滤器 -- 空间效率很高的数据结构》](https://segmentfault.com/a/1190000002729689)
* [《大量数据去重：Bitmap和布隆过滤器(Bloom Filter)》](https://blog.csdn.net/zdxiq000/article/details/57626464)
* [《基于Redis的布隆过滤器的实现》](https://blog.csdn.net/qq_30242609/article/details/71024458)
	* 基于 Redis 的 Bitmap 数据结构。
* [《网络爬虫：URL去重策略之布隆过滤器(BloomFilter)的使用》](https://blog.csdn.net/lemon_tree12138/article/details/47973715)
	* 使用Java中的 BitSet 类 和 加权和hash算法。

## 字符串比较

### KMP 算法
KMP：Knuth-Morris-Pratt算法（简称KMP）
核心原理是利用一个“部分匹配表”，跳过已经匹配过的元素。
* [《字符串匹配的KMP算法》](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)

## 深度优先、广度优先
* [《广度优先搜索BFS和深度优先搜索DFS》](https://www.cnblogs.com/0kk470/p/7555033.html)

## 贪心算法
* [《算法：贪婪算法基础》](https://www.cnblogs.com/MrSaver/p/8641971.html)
* [《常见算法及问题场景——贪心算法》](https://blog.csdn.net/a345017062/article/details/52443781)

## 回溯算法
* [《 五大常用算法之四：回溯法》](https://blog.csdn.net/qfikh/article/details/51960331)

## 剪枝算法
* [《α-β剪枝算法》](https://blog.csdn.net/luningcsdn/article/details/50930276)

## 动态规划
* [《详解动态规划——邹博讲动态规划》](https://www.cnblogs.com/little-YTMM/p/5372680.html)
* [《动态规划算法的个人理解》](https://blog.csdn.net/yao_zi_jie/article/details/54580283)

## 朴素贝叶斯

* [《带你搞懂朴素贝叶斯分类算法》](https://blog.csdn.net/amds123/article/details/70173402)
	* P(B|A)=P(A|B)P(B)/P(A)

* [《贝叶斯推断及其互联网应用1》](http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_one.html)
* [《贝叶斯推断及其互联网应用2》](http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_two.html)


## 推荐算法
* [《推荐算法综述》](http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part01)
* [《TOP 10 开源的推荐系统简介》](https://www.oschina.net/news/51297/top-10-open-source-recommendation-systems)

## 最小生成树算法
* [《算法导论--最小生成树（Kruskal和Prim算法）》](https://blog.csdn.net/luoshixian099/article/details/51908175)

## 最短路径算法

* [《Dijkstra算法详解》](https://blog.csdn.net/qq_35644234/article/details/60870719)

# 操作系统

## 计算机原理

* [《操作系统基础知识——操作系统的原理，类型和结构》](https://segmentfault.com/a/1190000003692840)

## CPU

### 多级缓存
典型的 CPU 有三级缓存，距离核心越近，速度越快，空间越小。L1 一般 32k，L2 一般 256k，L3 一般12M。内存速度需要200个 CPU 周期，CPU 缓存需要1个CPU周期。

* [《从Java视角理解CPU缓存和伪共享》](https://blog.csdn.net/zero__007/article/details/54089730)

## 进程

+ [《Linux进程间通信的实现原理》](https://zhuanlan.zhihu.com/p/69553562)
  + 方式：管道、命名管道、内存映射、消息队列、共享内存、信号量、信号、套接字

## 线程

* [《线程的生命周期及状态转换详解》](https://blog.csdn.net/asdf_1024/article/details/78978437)

## 协程

* [《终结python协程----从yield到actor模型的实现》](https://www.thinksaas.cn/group/topic/839375/)
	* 线程的调度是由操作系统负责，协程调度是程序自行负责
	* 与线程相比，协程减少了无谓的操作系统切换.
	* 实际上当遇到IO操作时做切换才更有意义，（因为IO操作不用占用CPU），如果没遇到IO操作，按照时间片切换.
* [《硬核系列 | 深入剖析 Java 协程》](https://xie.infoq.cn/article/cef6d2931a54f85142d863db7)
  * 协程可以减少CPU上下文切换，对IO密集型任务更友好；线程对CPU密集型任务更友好
  * 协程需要主动让出占用
  * 目前java三分库通过保存线程栈帧休息然后重新读取的方式进行协程的上下文切换
## Linux

* [《Linux 命令大全》](http://www.runoob.com/linux/linux-command-manual.html)

# 设计模式

## 设计模式的六大原则
* [《设计模式的六大原则》](https://blog.csdn.net/q291611265/article/details/48465113)
	* 开闭原则：对扩展开放,对修改关闭，多使用抽象类和接口。
	* 里氏替换原则：基类可以被子类替换，使用抽象类继承,不使用具体类继承。
	* 依赖倒转原则：要依赖于抽象,不要依赖于具体，针对接口编程,不针对实现编程。
	* 接口隔离原则：使用多个隔离的接口,比使用单个接口好，建立最小的接口。
	* 迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用，通过中间类建立联系。
	* 合成复用原则：尽量使用合成/聚合,而不是使用继承。

## 23种常见设计模式
* [《设计模式》](http://www.runoob.com/design-pattern/design-pattern-tutorial.html)
* [《23种设计模式全解析》](https://www.cnblogs.com/susanws/p/5510229.html)
* [《设计模式类图与示例》](https://github.com/ToryZhou/design-pattern)

## 应用场景
* [《细数JDK里的设计模式》](https://www.cnblogs.com/winkey4986/p/5148953.html)
	* 结构型模式：
		* 适配器：用来把一个接口转化成另一个接口，如 java.util.Arrays#asList()。
		* 桥接模式：这个模式将抽象和抽象操作的实现进行了解耦，这样使得抽象和实现可以独立地变化，如JDBC；
		* 组合模式：使得客户端看来单个对象和对象的组合是同等的。换句话说，某个类型的方法同时也接受自身类型作为参数，如 Map.putAll，List.addAll、Set.addAll。
		* 装饰者模式：动态的给一个对象附加额外的功能，这也是子类的一种替代方式，如 java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap。
		* 享元模式：使用缓存来加速大量小对象的访问时间，如 valueOf(int)。
		* 代理模式：代理模式是用一个简单的对象来代替一个复杂的或者创建耗时的对象，如 java.lang.reflect.Proxy
		
	* 创建模式:
		* 抽象工厂模式：抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型，如 java.util.Calendar#getInstance()。
		* 建造模式(Builder)：定义了一个新的类来构建另一个类的实例，以简化复杂对象的创建，如：java.lang.StringBuilder#append()。
		* 工厂方法：就是 **一个返回**具体对象的方法，而不是多个，如 java.lang.Object#toString()、java.lang.Class#newInstance()。
		* 原型模式：使得类的实例能够生成自身的拷贝、如：java.lang.Object#clone()。
		* 单例模式：全局只有一个实例，如 java.lang.Runtime#getRuntime()。
	* 行为模式：
		* 责任链模式：通过把请求从一个对象传递到链条中下一个对象的方式，直到请求被处理完毕，以实现对象间的解耦。如 javax.servlet.Filter#doFilter()。
		* 命令模式：将操作封装到对象内，以便存储，传递和返回，如：java.lang.Runnable。
		* 解释器模式：定义了一个语言的语法，然后解析相应语法的语句，如，java.text.Format，java.text.Normalizer。
		* 迭代器模式：提供一个一致的方法来顺序访问集合中的对象，如 java.util.Iterator。
		* 中介者模式：通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖，java.lang.reflect.Method#invoke()。
		* 空对象模式：如 java.util.Collections#emptyList()。
		* 观察者模式：它使得一个对象可以灵活的将消息发送给感兴趣的对象，如 java.util.EventListener。
		* 模板方法模式：让子类可以重写方法的一部分，而不是整个重写，如 java.util.Collections#sort()。

* [《Spring-涉及到的设计模式汇总》](https://www.cnblogs.com/hwaggLee/p/4510687.html)
* [《Mybatis使用的设计模式》](https://blog.csdn.net/u012387062/article/details/54719114)

## 单例模式
* [《单例模式的三种实现 以及各自的优缺点》](https://blog.csdn.net/YECrazy/article/details/79481964)
* [《单例模式－－反射－－防止序列化破坏单例模式》](https://www.cnblogs.com/ttylinux/p/6498822.html)
	* 使用枚举类型。

## 责任链模式
TODO

## MVC
* [《MVC 模式》](http://www.runoob.com/design-pattern/mvc-pattern.html)
	* 模型(model)－视图(view)－控制器(controller) 

## IOC
* [《理解 IOC》](https://www.zhihu.com/question/23277575)
* [《IOC 的理解与解释》](https://www.cnblogs.com/NancyStartOnce/p/6813162.html)
	* 正向控制：传统通过new的方式。反向控制，通过容器注入对象。
	* 作用：用于模块解耦。
	* DI：Dependency Injection，即依赖注入，只关心资源使用，不关心资源来源。

## AOP

* [《轻松理解AOP(面向切面编程)》](https://blog.csdn.net/yanquan345/article/details/19760027)
* [《Spring AOP详解》](https://www.cnblogs.com/hongwz/p/5764917.html)
* [《Spring AOP的实现原理》](http://www.importnew.com/24305.html)
	* Spring AOP使用的动态代理，主要有两种方式：JDK动态代理和CGLIB动态代理。
* [《Spring AOP 实现原理与 CGLIB 应用》](https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/)
	* Spring AOP 框架对 AOP 代理类的处理原则是：如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类 


## UML

* [《UML教程》](https://www.w3cschool.cn/uml_tutorial/)

## 微服务思想
* [《微服务架构设计》](https://www.cnblogs.com/wintersun/p/6219259.html)
* [《微服务架构技术栈选型手册》](http://www.infoq.com/cn/articles/micro-service-technology-stack)

### 康威定律
* [《微服务架构的理论基础 - 康威定律》](https://yq.aliyun.com/articles/8611)
	* 定律一：组织沟通方式会通过系统设计表达出来，就是说架构的布局和组织结构会有相似。
	* 定律二：时间再多一件事情也不可能做的完美，但总有时间做完一件事情。一口气吃不成胖子，先搞定能搞定的。
	* 定律三：线型系统和线型组织架构间有潜在的异质同态特性。种瓜得瓜，做独立自治的子系统减少沟通成本。
	* 定律四：大的系统组织总是比小系统更倾向于分解。合久必分，分而治之。

* [《微服务架构核⼼20讲》](https://static.geekbang.org/PDF-%E4%BF%AE%E6%94%B9%E7%89%88-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E5%9B%BE%E7%89%87-%E6%9D%A8%E6%B3%A2-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.pdf)

# Java基础

## 面向对象

### 对象模型

+ [《java对象结构》](https://blog.csdn.net/zqz_zqz/article/details/70246212)
  + 对象头(markword+klass); 实例数据(有效信息,父类+子类); 对齐填充(占位符)
  + markword: 运行时数据,包括希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等); 
  + klass: 类的元数据信息,类似于java.lang.Class对象，记录了类的全部信息
  + HotSpot虚拟机才用OOP-Klass模型(OOP=MarkWord+元数据指针,指针指向kclass)
+ [《Java对象在内存的结构》](https://juejin.cn/post/6844903832833490957)

### 对象加载

+ [《深入理解Java类加载器(ClassLoader)》](https://blog.csdn.net/javazejian/article/details/73413292)
  + 流程：加载（创建Class对象）->链接【验证（文件是否安全）->准备（类变量分配方法区内存并赋初始值）->解析（常量池中的符号引用替换为直接引用）】->初始化（类变量赋值）
  + 按需加载：需要使用该类时才会将它的class文件加载到内存生成class对象
  + 双亲委派模式优势：具备了一种带有优先级的层次关系，避免类重复加载；避免核心API库被篡改
  + 判定Class对象一致：类的完整类名必须一致；加载这个类的ClassLoader必须相同
  + SPI通过引导类加载器加载对象
+ [《关于Java类文件结构的详细介绍》](https://blog.csdn.net/u010963948/article/details/90080056)
  + 由单个 ClassFile 结构组成
  + 魔数+副/主版本号+常量池计数器/数据区+访问标志+类/父类索引+接口计数器/数据区+字段计数器/数据区+方法计数器/数据区+属性计数器/数据区
  + 魔数：头4个字节，用来确定是否可被JVM接收

### 对象结构

+ [《详解 HashMap 数据结构（JDK8）》](https://juejin.cn/post/6844904111817637901)
  + 数组+链表+红黑树（加快链表的查询效率）
  + Hash冲突解决方案：**链地址法**（hash 值相同时，则会将他们至于数组的同一个位置处，并以链表的形式呈现）（另外一种开放地址法：哈希完后如果有冲突，则按照某种规则找到空位插入）
  + 桶数量（key）大于指定64且链表长度大于8才会转换红黑树，否则进行扩容
  + 长度为2的N次幂，用于索引计算、扩容、重算索引可以提供执行效率（通过位运算）

## 内存管理

### 内存模型

+ [《Java内存模型（JMM）总结》](https://zhuanlan.zhihu.com/p/29881777)
  + JMM是一种虚拟机规范
  + 硬件层面的CPU、内存交互，JMM进行逻辑层面的内存模型和真实的硬件内存转换和交互
  + JMM解决的问题
    + 1.可见性：线程缓存导致的可见性问题；重排序导致的可见性问题=>volatile+synchronized+final
    + 2.原子性：多线程竞争=>变量8大操作; 锁
    + 3.有序性：指令重排导致的数据依赖=>happen-before原则
+ [《全面理解Java内存模型(JMM)及volatile关键字》](https://blog.csdn.net/javazejian/article/details/72772461)
  + 逻辑划分：运行时数据区【方法区（元空间）+堆+（虚拟机栈+本地方法栈+程序计数器）（私有）】+本地接口库+执行引擎
  + 方法区：类信息、常量、静态变量、即时编译器编译后的代码等
  + 虚拟机栈：变量表、操作数栈、动态链接方法、返回值、返回地址等

### 垃圾回收

+ [《咱们从头到尾说一次 Java 垃圾回收》](https://www.infoq.cn/article/zoyqri4c-bfkmubmzmkn)
  + 标记算法
    + 引用计数算法：相互引用的对象无法回收
    + 可达性分析算法：GC-Root对象（虚拟机栈-本地变量表中引用的对象、方法区-静态属性引用对象、方法区-常量引用对象、本地方法栈-JNI引用对象）
  + 清除算法
    + 标记-清除算法（Mark-Sweep）：内存碎片，复制算法（Copying）：内存利用率低下，标记-整理算法（Mark-Compact）：效率低下
    + 分代收集算法（Generational Collection）：理论
  + 堆内存：新生代【Eden+Survivor（From+To）】+老年代【Old】
    + Survivor 区目的：减少MajorGC，From+To区目的：减少内存碎片
    + 进入Old区：1.大对象；2.年龄超限；3.同年龄（Survivor区对象）数量过半
+ [《7 种 JVM 垃圾收集器》](https://cloud.tencent.com/developer/article/1592943)
  + 新生代：Serial（默认，单线程，复制算法），ParNew（多线程版本Serial，复制算法），Parallel Scavenge（并行，复制算法，吞吐量优先） 
  + 老年代：Serial Old（单线程，标记-整理算法），Parallel Old（对应Parallel Scavenge，标记-整理算法，吞吐量优先），CMS（标记-清除算法，最短回收停顿时间），G1（标记-整理+复制算法）
  + 单机单核下Serial性能最高，ParNew能与CMS配合使用，Parallel Old配合Parallel Scavenge使用
  + G1
    + 将堆划分为多个大小相等的独立区域Region
    + 可预测的时间模型：跟踪各个Region里面的垃圾堆积的价值大小，维护优先列表，优先回收价值最大的Region
    + 避免全堆扫描：维护对象跨Region使用的集合Remembered Set
+ [《逃逸分析与标量替换》](https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&mid=2247492444&idx=2&sn=f8d8a9cc4b2e66da2d532a562dda2bae)
  + 逃逸：返回对象地址，可由外部直接通过该返回访问对象
  + 标量替换：根据实际对象的构成，在没有逃逸的情况下(外部无法直接访问对象)，可能将对象拆解为基本类型
  + 两者都是为了减少对象分配

# 并发

## Java 并发

* [Java 并发知识合集](https://github.com/CL0610/Java-concurrency)
* [JAVA并发知识图谱](https://github.com/CL0610/Java-concurrency/blob/master/Java并发知识图谱.png)

## 多线程

* [《40个Java多线程问题总结》](https://www.cnblogs.com/xrq730/p/5060921.html)
* [《Java 线程池原理和队列详解》](https://blog.csdn.net/xx326664162/article/details/51701508)
  * 流程: 检查corePoolSize=>检查阻塞队列=>检查maximumPoolSize=>使用拒绝策略
  * 无界队列LinkedBlockingQueue,有界队列ArrayBlockingQueue
  * 拒绝策略: AbortPolicy(抛出异常),CallerRunsPolicy(调用者自运行),DiscardPolicy(抛弃任务),DiscardOldestPolicy(删除阻塞队列头部任务并加入)

## 线程安全

* [《Java并发编程——线程安全及解决机制简介》](https://www.cnblogs.com/zhanht/p/5450325.html)
* [《线程生命周期》](https://www.jianshu.com/p/19228c30ffed)
  * yield立即runnable, sleep休眠后runnable
  * wait释放锁, sleep不释放

## 一致性、事务

### 事务 ACID 特性
* [《数据库事务ACID特性》](https://blog.csdn.net/u012440687/article/details/52116108)

### 事务的隔离级别

* [《数据库事务的四大特性及事务隔离级别》](https://www.cnblogs.com/z-sm/p/7245981.html)
  * 未提交读：一个事务可以读取另一个未提交的数据，容易出现脏读的情况。
  * 读提交：一个事务等另外一个事务提交之后才可以读取数据，但会出现不可重复读的情况（多次读取的数据不一致），读取过程中出现UPDATE操作，会多。（大多数数据库默认级别是RC，比如SQL Server，Oracle），读取的时候不可以修改。
  * 可重复读： 同一个事务里确保每次读取的时候，获得的是同样的数据，但不保障原始数据被其他事务更新（幻读），Mysql InnoDB 就是这个级别。
  * 序列化：所有事物串行处理（牺牲了效率）
* [《MySQL的InnoDB的幻读问题 》](http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html)
	* 幻读的例子非常清楚。
	* 通过 SELECT ... FOR UPDATE 解决。
* [《一篇文章带你读懂MySQL和InnoDB》](https://draveness.me/mysql-innodb)
	* 图解脏读、不可重复读、幻读问题。


## 锁

### Java中的锁和同步类

* [《不可不说的Java“锁”事》](https://tech.meituan.com/2018/11/15/java-lock.html)
* [《Java并发之AQS详解》](https://www.cnblogs.com/waterystone/p/4920797.html)
* [《Java中信号量 Semaphore》](https://blog.csdn.net/zlp1992/article/details/52703793)
	* 有数量控制
	* 申请用 acquire，申请不要则阻塞；释放用 release。
* [《java开发中的Mutex vs Semaphore》](https://www.cnblogs.com/davidwang456/p/6094947.html)
	* 简单的说 就是Mutex是排它的，只有一个可以获取到资源， Semaphore也具有排它性，但可以定义多个可以获取的资源的对象。	 

### 公平锁 & 非公平锁

公平锁的作用就是严格按照线程启动的顺序来执行的，不允许其他线程插队执行的；而非公平锁是允许插队的。

* [《公平锁与非公平锁》](https://blog.csdn.net/EthanWhite/article/details/55508357)
	* 默认情况下 ReentrantLock 和 synchronized 都是非公平锁。ReentrantLock 可以设置成公平锁。

### 悲观锁 & 乐观锁

* [《【MySQL】悲观锁&乐观锁》](https://www.cnblogs.com/zhiqian-ali/p/6200874.html)
	* 乐观锁的方式：版本号+重试方式
	* 悲观锁：通过 select ... for update 进行行锁(不可读、不可写，share 锁可读不可写)。


* [《乐观锁的一种实现方式——CAS》](https://blog.csdn.net/u011514810/article/details/76895723/)
	* 和MySQL乐观锁方式相似，只不过是通过和原值进行比较。	 

### 可重入锁 & 不可重入锁

* [《可重入锁和不可重入锁》](https://www.cnblogs.com/dj3839/p/6580765.html)
  * 可重入锁指同一个线程可以再次获得之前已经获得的锁。
  * 可重入锁可以用户避免死锁。
  * Java中的可重入锁：synchronized 和 java.util.concurrent.locks.ReentrantLock

* [《ReenTrantLock可重入锁（和synchronized的区别）总结》](https://www.cnblogs.com/baizhanshi/p/7211802.html)
  * synchronized 使用方便，编译器来加锁，是非公平锁。
  * ReenTrantLock 使用灵活，锁的公平性可以定制。
  * 相同加锁场景下，推荐使用 synchronized。

### 互斥锁 & 共享锁

互斥锁：同时只能有一个线程获得锁。比如，ReentrantLock 是互斥锁，ReadWriteLock 中的写锁是互斥锁。
共享锁：可以有多个线程同时或的锁。比如，Semaphore、CountDownLatch 是共享锁，ReadWriteLock 中的读锁是共享锁。

* [《ReadWriteLock场景应用》](https://www.cnblogs.com/liang1101/p/6475555.html)

### ABA 问题

由于高并发，在CAS下，更新后可能此A非彼A。通过版本号可以解决，类似于上文Mysql 中提到的的乐观锁。

* [《Java CAS 和ABA问题》](https://www.cnblogs.com/549294286/p/3766717.html)
* [《Java 中 ABA问题及避免》](https://blog.csdn.net/li954644351/article/details/50511879)
	* AtomicStampedReference 和 AtomicStampedReference。 

### CopyOnWrite容器

可以对CopyOnWrite容器进行并发的读，而不需要加锁。CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，不适合需要数据强一致性的场景。

* [《JAVA中写时复制(Copy-On-Write)Map实现》](https://www.cnblogs.com/hapjin/p/4840107.html)
	* 实现读写分离，读取发生在原始数据上，写入发生在副本上。  
	* 不用加锁，通过最终一致实现一致性。
	
* [《聊聊并发-Java中的Copy-On-Write容器》](https://blog.csdn.net/a494303877/article/details/53404623)

### RingBuffer 
* [《线程安全的无锁RingBuffer的实现【一个读线程，一个写线程】》](http://www.cnblogs.com/l00l/p/4115001.html)

### 死锁
* [《“死锁”四个必要条件的合理解释》](https://blog.csdn.net/yunfenglw/article/details/45950305)
	* 互斥、持有、不可剥夺、环形等待。
* [Java如何查看死锁？](https://blog.csdn.net/u014039577/article/details/52351626)
	* JConsole 可以识别死锁。
* [java多线程系列：死锁及检测](https://blog.csdn.net/bohu83/article/details/51135061)
	* jstack 可以显示死锁。
* [《Mysql查询语句使用select.. for update导致的数据库死锁分析》](https://www.cnblogs.com/Lawson/p/5008741.html)
  * mysql的innodb存储引擎实务锁虽然是锁行，但它内部是锁索引的。
  * 锁相同数据的不同索引条件可能会引起死锁。

* [《Mysql并发时经典常见的死锁原因及解决方法》](https://www.cnblogs.com/zejin2008/p/5262751.html)

# 运维 & 统计 & 技术支持 

## 常规监控

* [《腾讯业务系统监控的修炼之路》](https://blog.csdn.net/enweitech/article/details/77849205)
	* 监控的方式：主动、被动、旁路(比如舆情监控)
	* 监控类型： 基础监控、服务端监控、客户端监控、监控、用户端监控
	* 监控的目标：全、块、准
	* 核心指标：请求量、成功率、耗时
	
* [《开源还是商用？十大云运维监控工具横评》](https://www.oschina.net/news/67525/monitoring-tools)
	* Zabbix、Nagios、Ganglia、Zenoss、Open-falcon、监控宝、 360网站服务监控、阿里云监控、百度云观测、小蜜蜂网站监测等。

* [《监控报警系统搭建及二次开发经验》](http://developer.51cto.com/art/201612/525373.htm)

**命令行监控工具**

* [《常用命令行监控工具》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/44-an-quan-yu-yun-wei/445-fu-wu-qi-zhuang-tai-jian-ce/4451-ming-ling-xing-gong-ju.html)
	* top、sar、tsar、nload

* [《20个命令行工具监控 Linux 系统性能》](http://blog.jobbole.com/96846/)

* [《JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解》](https://my.oschina.net/feichexia/blog/196575)

## APM

APM —  Application Performance Management

* [《Dapper，大规模分布式系统的跟踪系统》](http://bigbully.github.io/Dapper-translation/)

* [CNCF OpenTracing](http://opentracing.io)，[中文版](https://github.com/opentracing-contrib/opentracing-specification-zh)

* 主要开源软件，按字母排序
  * [Apache SkyWalking](https://github.com/apache/incubator-skywalking)
  * [CAT](https://github.com/dianping/cat)
  * [CNCF jaeger](https://github.com/jaegertracing/jaeger)
  * [Pinpoint](https://github.com/naver/pinpoint)
  * [Zipkin](https://github.com/openzipkin/zipkin)

* [《开源APM技术选型与实战》](http://www.infoq.com/cn/articles/apm-Pinpoint-practice)
	* 主要基于 Google的Dapper（大规模分布式系统的跟踪系统） 思想。


## 统计分析

* [《流量统计的基础：埋点》](https://zhuanlan.zhihu.com/p/25195217)
	* 常用指标：访问与访客、停留时长、跳出率、退出率、转化率、参与度

* [《APP埋点常用的统计工具、埋点目标和埋点内容》](http://www.25xt.com/company/17066.html)
	* 第三方统计：友盟、百度移动、魔方、App Annie、talking data、神策数据等。

* [《美团点评前端无痕埋点实践》](https://tech.meituan.com/mt_mobile_analytics_practice.html)
	* 所谓无痕、即通过可视化工具配置采集节点，在前端自动解析配置并上报埋点数据，而非硬编码。 


## 持续集成(CI/CD)

* [《持续集成是什么？》](http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html)
* [《8个流行的持续集成工具》](http://www.51testing.com/html/74/n-3723774.html)

### Jenkins

* [《使用Jenkins进行持续集成》](https://www.liaoxuefeng.com/article/001463233913442cdb2d1bd1b1b42e3b0b29eb1ba736c5e000)

## 自动化运维

### Ansible
* [《Ansible中文权威指南》](http://www.ansible.com.cn/)
* [《Ansible基础配置和企业级项目实用案例》](https://www.cnblogs.com/heiye123/articles/7855890.html)

### puppet
* [《自动化运维工具——puppet详解》](https://www.cnblogs.com/keerya/p/8040071.html)

### chef
* [《Chef 的安装与使用》](https://www.ibm.com/developerworks/cn/cloud/library/1407_caomd_chef/)

## 测试

### TDD 理论

* [《深度解读 - TDD（测试驱动开发）》](https://www.jianshu.com/p/62f16cd4fef3)
	* 基于测试用例编码功能代码，XP（Extreme Programming）的核心实践.
	* 好处：一次关注一个点，降低思维负担；迎接需求变化或改善代码的设计；提前澄清需求；快速反馈； 

### 单元测试

* [《Java单元测试之JUnit篇》](https://www.cnblogs.com/happyzm/p/6482886.html)
* [《JUnit 4 与 TestNG 对比》](https://blog.csdn.net/hotdust/article/details/53406086)
	* TestNG 覆盖 JUnit 功能，适用于更复杂的场景。 
* [《单元测试主要的测试功能点》](https://blog.csdn.net/wqetfg/article/details/50900512)
	* 模块接口测试、局部数据结构测试、路径测试 、错误处理测试、边界条件测试 。 

### 压力测试

* [《Apache ab 测试使用指南》](https://blog.csdn.net/blueheart20/article/details/52170790)
* [《大型网站压力测试及优化方案》](https://www.cnblogs.com/binyue/p/6141088.html)
* [《10大主流压力/负载/性能测试工具推荐》](http://news.chinabyte.com/466/14126966.shtml)
* [《真实流量压测工具 tcpcopy应用浅析》](http://quentinxxz.iteye.com/blog/2249799)
* [《nGrinder 简易使用教程》](https://www.cnblogs.com/jwentest/p/7136727.html)


### 全链路压测
* [《京东618：升级全链路压测方案，打造军演机器人ForceBot》](http://www.infoq.com/cn/articles/jd-618-upgrade-full-link-voltage-test-program-forcebot)
* [《饿了么全链路压测的探索与实践》](https://zhuanlan.zhihu.com/p/30306892)
* [《四大语言，八大框架｜滴滴全链路压测解决之道》](https://zhuanlan.zhihu.com/p/28355759)
* [《全链路压测经验》](https://www.jianshu.com/p/27060fd61f72)


### A/B 、灰度、蓝绿测试

* [《技术干货 | AB 测试和灰度发布探索及实践》](https://testerhome.com/topics/11165)
* [《nginx 根据IP 进行灰度发布》](http://blog.51cto.com/purplegrape/1403123)

* [《蓝绿部署、A/B 测试以及灰度发布》](https://www.v2ex.com/t/344341)

## 虚拟化

* [《VPS的三种虚拟技术OpenVZ、Xen、KVM优缺点比较》](https://blog.csdn.net/enweitech/article/details/52910082)

### KVM
* [《KVM详解，太详细太深入了，经典》](http://blog.chinaunix.net/uid-20201831-id-5775661.html)
* [《【图文】KVM 虚拟机安装详解》](https://www.coderxing.com/kvm-install.html)

### Xen
* [《Xen虚拟化基本原理详解》](https://www.cnblogs.com/sddai/p/5931201.html)

### OpenVZ
* [《开源Linux容器 OpenVZ 快速上手指南》](https://blog.csdn.net/longerzone/article/details/44829255)

## 容器技术

### Docker
* [《几张图帮你理解 docker 基本原理及快速入门》](https://www.cnblogs.com/SzeCheng/p/6822905.html)
* [《Docker 核心技术与实现原理》](https://draveness.me/docker)
* [《Docker 教程》](http://www.runoob.com/docker/docker-tutorial.html)

## 云技术

### OpenStack
* [《OpenStack构架知识梳理》](https://www.cnblogs.com/klb561/p/8660264.html)

## DevOps
* [《一分钟告诉你究竟DevOps是什么鬼？》](https://www.cnblogs.com/jetzhang/p/6068773.html)
* [《DevOps详解》](http://www.infoq.com/cn/articles/detail-analysis-of-devops)

## 文档管理

* [Confluence-收费文档管理系统](http://www.confluence.cn/)
* GitLab?
* Wiki

# 中间件

## Web Server

### Nginx
* [《Ngnix的基本学习-多进程和Apache的比较》](https://blog.csdn.net/qq_25797077/article/details/52200722)
	* Nginx 通过异步非阻塞的事件处理机制实现高并发。Apache 每个请求独占一个线程，非常消耗系统资源。
	* 事件驱动适合于IO密集型服务(Nginx)，多进程或线程适合于CPU密集型服务(Apache)，所以Nginx适合做反向代理，而非web服务器使用。  

* [《nginx与Apache的对比以及优缺点》](https://www.cnblogs.com/cunkouzh/p/5410154.html)
	* nginx只适合静态和反向代理，不适合处理动态请求。

### OpenResty
* [官方网站](http://openresty.org/cn/)
* [《浅谈 OpenResty》](http://www.linkedkeeper.com/detail/blog.action?bid=1034)
	* 通过 Lua 模块可以在Nginx上进行开发。   
* [agentzh 的 Nginx 教程](https://openresty.org/download/agentzh-nginx-tutorials-zhcn.html)  
### Tengine
* [官方网站](http://tengine.taobao.org/)  

### Apache Httpd
* [官方网站](http://httpd.apache.org/)

### Tomcat

#### 架构原理
* [《TOMCAT原理详解及请求过程》](https://www.cnblogs.com/hggen/p/6264475.html)
* [《Tomcat服务器原理详解》](https://www.cnblogs.com/crazylqy/p/4706223.html)
* [《Tomcat 系统架构与设计模式,第 1 部分: 工作原理》](https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/)

* [《四张图带你了解Tomcat系统架构》](https://blog.csdn.net/xlgen157387/article/details/79006434)

* [《JBoss vs. Tomcat: Choosing A Java Application Server》](https://www.futurehosting.com/blog/jboss-vs-tomcat-choosing-a-java-application-server/)
	* Tomcat 是轻量级的 Serverlet 容器，没有实现全部 JEE 特性（比如持久化和事务处理），但可以通过其他组件代替，比如Spring。
	* Jboss 实现全部了JEE特性，软件开源免费、文档收费。

#### 调优方案

* [《Tomcat 调优方案》](https://www.cnblogs.com/sunfenqing/p/7339058.html)
	* 启动NIO模式（或者APR）；调整线程池；禁用AJP连接器（Nginx+tomcat的架构，不需要AJP）； 

* [《tomcat http协议与ajp协议》](http://blog.chinaunix.net/uid-20662363-id-3012760.html)
* [《AJP与HTTP比较和分析》](http://dmouse.iteye.com/blog/1354527)
	* AJP 协议（8009端口）用于降低和前端Server（如Apache，而且需要支持AJP协议）的连接数(前端)，通过长连接提高性能。
	* 并发高时，AJP协议优于HTTP协议。

### Jetty
* [《Jetty 的工作原理以及与 Tomcat 的比较》](https://www.ibm.com/developerworks/cn/java/j-lo-jetty/)
* [《jetty和tomcat优势比较》](https://blog.csdn.net/doutao6677/article/details/51957288)
	* 架构比较:Jetty的架构比Tomcat的更为简单。
	* 性能比较：Jetty和Tomcat性能方面差异不大，Jetty默认采用NIO结束在处理I/O请求上更占优势，Tomcat默认采用BIO处理I/O请求，Tomcat适合处理少数非常繁忙的链接，处理静态资源时性能较差。
	* 其他方面：Jetty的应用更加快速，修改简单，对新的Servlet规范的支持较好;Tomcat 对JEE和Servlet 支持更加全面。 



## 缓存

* [《缓存失效策略（FIFO 、LRU、LFU三种算法的区别）》](https://blog.csdn.net/clementad/article/details/48229243)

### 本地缓存

* [《HashMap本地缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4211.html)

* [《EhCache本地缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4212-ehcache.html)
	* 堆内、堆外、磁盘三级缓存。
	* 可按照缓存空间容量进行设置。
	* 按照时间、次数等过期策略。

* [《Guava Cache》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4213-guava-cache.html)
	* 简单轻量、无堆外、磁盘缓存。


* [《Nginx本地缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/nginx-ben-di-huan-cun.html)

* [《Pagespeed—懒人工具，服务器端加速》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/4222-pagespeed.html)

## 客户端缓存

* [《浏览器端缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/423-ke-hu-duan-huan-cun.html)
	* 主要是利用 Cache-Control 参数。

* [《H5 和移动端 WebView 缓存机制解析与实战》](https://mp.weixin.qq.com/s/qHm_dJBhVbv0pJs8Crp77w)

## 服务端缓存

### Web缓存

* [nuster](https://github.com/jiangwenyuan/nuster) - nuster cache
* [varnish](https://github.com/varnishcache/varnish-cache) - varnish cache
* [squid](https://github.com/squid-cache/squid) - squid cache

### Memcached
* [《Memcached 教程》](http://www.runoob.com/Memcached/Memcached-tutorial.html)
* [《深入理解Memcached原理》](https://blog.csdn.net/chenleixing/article/details/47035453)
	* 采用多路复用技术提高并发性。
	* slab分配算法： memcached给Slab分配内存空间，默认是1MB。分配给Slab之后 把slab的切分成大小相同的chunk，Chunk是用于缓存记录的内存空间，Chunk 的大小默认按照1.25倍的速度递增。好处是不会频繁申请内存，提高IO效率，坏处是会有一定的内存浪费。
* [《Memcached软件工作原理》](https://www.jianshu.com/p/36e5cd400580)
* [《Memcache技术分享：介绍、使用、存储、算法、优化、命中率》](http://zhihuzeye.com/archives/2361)

* [《memcache 中 add 、 set 、replace 的区别》](https://blog.csdn.net/liu251890347/article/details/37690045)
	* 区别在于当key存在还是不存在时，返回值是true和false的。

* [**《memcached全面剖析》**](https://pan.baidu.com/s/1qX00Lti?errno=0&errmsg=Auth%20Login%20Sucess&&bduss=&ssnerror=0&traceid=)

### Redis

* [《Redis 教程》](http://www.runoob.com/redis/redis-tutorial.html)
* [《redis底层存储模型》](https://i6448038.github.io/2019/12/01/redis-data-struct/)
	* 使用 ziplist 存储链表，ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。
	* 使用 skiplist(跳跃表)来存储有序集合对象、查找上先从高Level查起、时间复杂度和红黑树相当，实现容易，无锁、并发性好。
* [《Redis持久化方式》](http://doc.redisfans.com/topic/persistence.html)
	* RDB方式：定期备份快照，常用于灾难恢复。优点：通过fork出的进程进行备份，不影响主进程、RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。缺点：会丢数据。
	* AOF方式：保存操作日志方式。优点：恢复时数据丢失少，缺点：文件大，回复慢。
	* 也可以两者结合使用。

* [《分布式缓存--序列3--原子操作与CAS乐观锁》](https://blog.csdn.net/chunlongyu/article/details/53346436)

* [《为什么Redis单线程还这么快？》](http://kaito-kidd.com/2020/06/28/why-redis-so-fast/)
  * 纯内存操作：响应时间大约是100纳秒=>每秒万亿级别访问
  * 使用IO多路复用技术：采用epoll做为I/O多路复用技术, 连接，读写，关闭都转换为了时间不消耗IO
  * 单线程的优势：没有了多线程上下文切换、访问共享资源加锁的性能损耗
  * Server多线程，请求单线程

### Tair

* [官方网站](https://github.com/alibaba/tair)
* [《Tair和Redis的对比》](http://blog.csdn.net/farphone/article/details/53522383)
* 特点：可以配置备份节点数目，通过异步同步到备份节点
* 一致性Hash算法。
* 架构：和Hadoop 的设计思想类似，有Configserver，DataServer，Configserver 通过心跳来检测，Configserver也有主备关系。


几种存储引擎:
* MDB，完全内存性，可以用来存储Session等数据。
* Rdb（类似于Redis），轻量化，去除了aof之类的操作，支持Restfull操作
* LDB（LevelDB存储引擎），持久化存储，LDB 作为rdb的持久化，google实现，比较高效，理论基础是LSM(Log-Structured-Merge Tree)算法，现在内存中修改数据，达到一定量时（和内存汇总的旧数据一同写入磁盘）再写入磁盘，存储更加高效，县比喻Hash算法。
* Tair采用共享内存来存储数据，如果服务挂掉（非服务器），重启服务之后，数据亦然还在。

## 消息队列

+ [《消息队列设计精要》](https://tech.meituan.com/2016/07/01/mq-design.html)
  + 消息队列的本质, 基础能力和高阶能力
  + 顺序消息: 单线程+可丢失
  + 可靠投递: 消息落地+可重复
  + Push方式：优点是可以尽可能快地将消息发送给消费者，缺点是如果消费者处理能力跟不上，消费者的缓冲区可能会溢出。
  + Pull方式：优点是消费端可以按处理能力进行拉去，缺点是会增加消息延迟。

* [《消息队列选型-原理及常用MQ特点》](https://juejin.cn/post/6844904119598055437)
  * 协议AMQP定义了 Message ACK => at-least-once
  * 协议AMQP定义了 tx transaction => 阻塞调用, 保证无重复投递
* 消息堆积问题: 临时扩容consumer快速消费; 扔入死信队列缓慢消费
* 消息过期失效: 重投递

### 消息总线

消息总线相当于在消息队列之上做了一层封装，统一入口，统一管控、简化接入成本。

* [《消息总线VS消息队列》](https://blog.csdn.net/yanghua_kobe/article/details/43877281)

### RabbitMQ

支持事务，推拉模式都是支持、适合需要可靠性消息传输的场景, 支持可靠性投递(confirm)/可靠性消费(ACK/手动应答)/消息跟踪(Tracing)。

* [《RabbitMQ的应用场景以及基本原理介绍》](https://blog.csdn.net/whoamiyang/article/details/54954780)
  * 投递失败机制: 自动删除或返回客户端
* [《RabbitMQ之消息确认机制（事务+Confirm）》](https://blog.csdn.net/u013256816/article/details/55515234)
  * 使用**publisher confirm**机制优化了AMQP的 TX, 使得producer可以持续发送消息, 通过Confirm异步确认
  * 确认在投递到队列或写入磁盘后发出

### RocketMQ
Java实现，推拉模式都是支持，吞吐量逊于Kafka, 支持可靠投递(事务)/可靠消费(ACK)/顺序消息/事务消息

* [《RocketMQ 源码解析》](http://www.iocoder.cn/categories/RocketMQ/?vip&architect-awesome)
  * 通信: 自定义了通信协议并在Netty的基础之上扩展了通信模块
  * 通信协议文本模型: 消息长度+序列化类型&头长度+消息头数据+消息体数据
  * netty Ractory模型优化: 1+M+N1+N2, **Reactor 主线程**(建立socket连接)+**Reactor 线程池**(监听网络数据)+**Worker线程池**(通信处理:编/解码+链接管理)+**业务processor处理线程池**(处理实际业务请求)
* [《RocketMQ 顺序消息》](https://xie.infoq.cn/article/fba37afd9bda31fb10eec651f)
  * 顺序发送: 使用**关键值hash**的方式保证投递到同一个队列
  * 顺序消费: 单线程消费

+ [《消息队列的分布式事务》](https://zhuanlan.zhihu.com/p/101974130)
  + 两阶段提交: 消息投递时mq server确认接收消息; producer完成本地事务后mq server确认事务状态
  + 保证: 本地事务和消息投递都成功或失败

### ActiveMQ
纯Java实现，兼容JMS，可以内嵌于Java应用中。
* [《消息队列-推/拉模式学习 & ActiveMQ及JMS学习》](https://www.cnblogs.com/charlesblc/p/6045238.html)

### Kafka
高吞吐量、采用拉模式。适合高IO场景，比如日志同步。

* [《各消息队列对比，Kafka深度解析》](https://blog.csdn.net/allthesametome/article/details/47362451)
  * consumer group=广播, group内consumer=集群消费
  * 高吞吐支持: 1.物理分区拓展;2.顺序写磁盘;3.broker无状态(是否消费由consumer的offset控制,可调整offset重复消费);4.分段;5.稀疏索引
* [《Kafka索引与日志文件结构》](https://blog.csdn.net/qq_32727095/article/details/108012552)
  * segament: log文件(消息)+index文件(偏移量索引)+timeindex文件(时间戳索引), 通过该segament最小offset命名
  * log文件: message(offset+消息大小+消息体)
  * index文件: offset与物理地址映射, 分段: 每隔一些消息建立一个索引, 稀疏索引:分段消息的baseOffset及其他消息相对baseOffset的**相对偏移量**
  * timeindex文件: 偏移量索引基本一致, 定位之后再跟进偏移量索引确定物理地址

+ [《消息队列的分布式事务》](https://zhuanlan.zhihu.com/p/101974130)
  + 使用事务协调者(broker一部分)进行事务管理
  + producer请求协调者创建事务->发送消息定位(主题分区)->发送消息给broker->发送提交或回滚给协调者->协调者确认事务结束,开放消息对consumer可见
  + 保证: 同事务中所有消息都成功或失败

### Redis 消息推送

生产者、消费者模式完全是客户端行为，list 和 拉模式实现，阻塞等待采用 blpop 指令。

* [《Redis学习笔记之十：Redis用作消息队列》](https://blog.csdn.net/qq_34212276/article/details/78455004)
  * 基于List实现, 基于BRPOP和BLPOP指令, 基于发布/订阅模式指令

### ZeroMQ
 TODO


## 定时调度

### 单机定时调度

* [《linux定时任务cron配置》](https://www.cnblogs.com/shuaiqing/p/7742382.html)

* [《Linux cron运行原理》](https://my.oschina.net/daquan/blog/483305)
	* fork 进程 + sleep 轮询

* [《Quartz使用总结》](https://www.cnblogs.com/drift-ice/p/3817269.html)
* [《Quartz源码解析 ---- 触发器按时启动原理》](https://blog.csdn.net/wenniuwuren/article/details/42082981/)
* [《quartz原理揭秘和源码解读》](https://www.jianshu.com/p/bab8e4e32952)
	* 定时调度在 QuartzSchedulerThread 代码中，while()无限循环，每次循环取出时间将到的trigger，触发对应的job，直到调度器线程被关闭。


### 分布式定时调度

* [《这些优秀的国产分布式任务调度系统，你用过几个？》](https://blog.csdn.net/qq_16216221/article/details/70314337)
	* opencron、LTS、XXL-JOB、Elastic-Job、Uncode-Schedule、Antares

* [《Quartz任务调度的基本实现原理》](https://www.cnblogs.com/zhenyuyaodidiao/p/4755649.html)
	* Quartz集群中，独立的Quartz节点并不与另一其的节点或是管理节点通信，而是通过相同的数据库表来感知到另一Quartz应用的 
* [《Elastic-Job-Lite 源码解析》](http://www.iocoder.cn/categories/Elastic-Job-Lite/?vip&architect-awesome)
* [《Elastic-Job-Cloud 源码解析》](http://www.iocoder.cn/categories/Elastic-Job-Cloud/?vip&architect-awesome)


## RPC

### Dubbo
* [官方网站](http://dubbo.apache.org/)
* [《dubbo实现原理简单介绍》](https://www.cnblogs.com/steven520213/p/7606598.html)
  * 基于长链接推送服务端变更消息给到消费端
* [《Dubbo服务暴露过程》](https://juejin.cn/post/6874731589243240461)
  * 流程：检测配置=>暴露服务=>注册服务，对象：服务实现类=>Invoker；Invoker=协议=>Exporter
  * Spring初始化ServiceBean=>IoC容器完成刷新=>`ServiceBean#onApplicationEvent()`=>`ServiceConfig#export()`=>ProxyFactory将通过javassist（快）实现类包装成Invoker=>（SPI）`protocol#exported()`转换为Exporter，加入本地缓存exporterMap=>`Exporter#openServer()`暴露服务=>注册
  * ***Protocol=ProtocolFilterWrapper + ProtocolListenerWrapper
* [《Dubbo的服务引用过程》](https://mp.weixin.qq.com/s/9oDy1OPcfDaEhKD4eNUdOA)
  * Sring初始化ReferenceBean=>`ReferenceBean.afterPropertiesSet ()`=>`ReferenceConfig#createProxy()`=>`RegisterProtocol#refer()`
  * createProxy：生成消费者链接并注册自己，封装合并后的Invoker
  * refer：创建路由规则；订阅服务者信息（Zookeeper.subscribe）；维护一个RegisterDirectory（Invoker列表）；创建消费端Invoker，包括NettyClient，集群合并Invoker；
* [《Dubbo服务调用过程》](https://mp.weixin.qq.com/s/oNR9v_ID2oAlEvDI93hRcw)
  * （SPI）根据集群确定策略从Directory获取一个Invoker列表=>路由router过滤=>（SPI）负载均衡选择Invoker=>序列化后NettyClient发送请求=>NettyServer收到请求后反序列化并分给线程池=>从exporterMap获取实现类处理=>Future回调

+ [《Dubbo的SPI机制》](https://mp.weixin.qq.com/s/gwWOsdQGEN0t2GJVMQQexw)
  + Java SPI（Service Provider Interface） 不足：将实现类全部实例化，无法按需加载实现类
  + Dubbo SPI：根据名字从文件中获取全限定名，先找实现类，判断缓存是否有实例，没有就反射建个实例，然后执行 set 方法依赖注入。如果有找到包装类的话，再包一层

### Thrift
* [官方网站](http://thrift.apache.org/)
* [《Thrift RPC详解》](https://blog.csdn.net/kesonyk/article/details/50924489)
	* 支持多语言，通过中间语言定义接口。

### gRPC

服务端可以认证加密，在外网环境下，可以保证数据安全。

* [官方网站](https://grpc.io/)
* [《你应该知道的RPC原理》](https://www.cnblogs.com/LBSer/p/4853234.html)


## 数据库中间件

### Sharding Jdbc

* [官网](http://shardingjdbc.io/)
* [源码解析](http://www.iocoder.cn/categories/Sharding-JDBC/?vip&architect-awesome)

## 日志系统

### 日志搜集

* [《从零开始搭建一个ELKB日志收集系统》](http://cjting.me/misc/build-log-system-with-elkb/)
* [《用ELK搭建简单的日志收集分析系统》](https://blog.csdn.net/lzw_2006/article/details/51280058)
* [《日志收集系统-探究》](https://www.cnblogs.com/beginmind/p/6058194.html)

## 配置中心

* [Apollo - 携程开源的配置中心应用](https://github.com/ctripcorp/apollo)
	* Spring Boot 和 Spring Cloud
	* 支持推、拉模式更新配置
	* 支持多种语言 

* [《基于zookeeper实现统一配置管理》](https://blog.csdn.net/u011320740/article/details/78742625)

* [《 Spring Cloud Config 分布式配置中心使用教程》](https://www.cnblogs.com/shamo89/p/8016908.html)

servlet 3.0 异步特性可用于配置中心的客户端
* [《servlet3.0 新特性——异步处理》](https://www.cnblogs.com/dogdogwang/p/7151866.html)

## API 网关

主要职责：请求转发、安全认证、协议转换、容灾。

* [《API网关那些儿》](http://yunlzheng.github.io/2017/03/14/the-things-about-api-gateway/)
* [《谈API网关的背景、架构以及落地方案》](http://www.infoq.com/cn/news/2016/07/API-background-architecture-floo)

* [《使用Zuul构建API Gateway》](https://blog.csdn.net/zhanglh046/article/details/78651993)
* [《Spring Cloud Gateway 源码解析》](http://www.iocoder.cn/categories/Spring-Cloud-Gateway/?vip&architect-awesome)
* [《HTTP API网关选择之一Kong介绍》](https://mp.weixin.qq.com/s/LIq2CiXJQmmjBC0yvYLY5A)

# 网络


## 协议

### OSI 七层协议

* [《OSI七层协议模型、TCP/IP四层模型学习笔记》](https://www.cnblogs.com/Robin-YB/p/6668762.html)

### TCP/IP、UDP
* [《深入浅出 TCP/IP 协议》](https://www.cnblogs.com/onepixel/p/7092302.html)
  * 各层跟进对应协议包装数据并携带对应的**首部**，最终在链路层生成**以太网数据包**, 从上到下
  * 链路层: **对电信号进行分组并形成具有特定意义的数据帧，然后以广播的形式通过物理介质发送给接收方(MAC地址)**
  * 网络层: **定义网络地址，区分网段，子网内MAC寻址，对于不同子网的数据包进行路由**
  * 传输层: **定义端口，标识应用程序身份，实现端口到端口的通信，TCP协议可以保证数据传输的可靠性**
  * 应用层: **定义数据格式并按照对应的格式解读数据**
* [《TCP协议中的三次握手和四次挥手》](https://blog.csdn.net/whuslei/article/details/6667471/)
* [《一文搞懂TCP与UDP的区别》](https://www.cnblogs.com/fundebug/p/differences-of-tcp-and-udp.html)
  * TCP：面向连接的可靠传输，流量控制，一对一，面向字节流，首部20-60字节
  * UDP：无连接的不可靠传输，一对N，面向报文，首部8+字节
* [《图解 TCP 重传、滑动窗口、流量控制、拥塞控制》](https://zhuanlan.zhihu.com/p/135932018)
  * 重传机制：超时（超时无应答重传）、快速（收到三个相同的 ACK 报文）、SACK（TCP 头部字段里加一个 SACK）、D-SACK（SACK告知重复接收）
  * 窗口：发送方在缓存中保存未确认应答的数据包，接收端TCP头字段Window控制大小
  * 流量控制：避免「发送方」的数据填满「接收方」的缓存
  * 拥塞控制：避免「发送方」的数据填满整个网络，超时重传=拥塞，实际窗口=min（拥塞窗口，接收窗口）
    * 算法：慢启动、拥塞避免、拥塞发生、快速恢复（主要根据拥塞窗口算法进行区分）

### HTTP
* [《http协议详解(超详细)》](https://www.cnblogs.com/wangning528/p/6388464.html)

### HTTP2.0
* [《HTTP 2.0 原理详细分析》](https://blog.csdn.net/zhuyiquan/article/details/69257126)
  * 利用二进制帧负责传输。
  * 多路复用。

### HTTPS
* [《https原理通俗了解》](https://www.cnblogs.com/zhangshitong/p/6478721.html)
	* 使用非对称加密协商加密算法
	* 使用对称加密方式传输数据
	* 使用第三方机构签发的证书，来加密公钥，用于公钥的安全传输、防止被中间人串改。

* [《SSL/TLS工作原理》](https://zhuanlan.zhihu.com/p/66029254)

## 网络模型

* [《web优化必须了解的原理之I/o的五种模型和web的三种工作模式》](http://blog.51cto.com/litaotao/1289790)
	* 五种I/O模型：阻塞I/O，非阻塞I/O，I/O复用、事件(信号)驱动I/O、异步I/O，前四种I/O属于同步操作，I/O的第一阶段不同、第二阶段相同，最后的一种则属于异步操作。
	* 三种 Web Server 工作方式：Prefork(多进程)、Worker方式(线程方式)、Event方式。

* [《select、poll、epoll之间的区别总结》](http://www.cnblogs.com/Anker/p/3265058.html)
	* select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。
	* select 有打开文件描述符数量限制，默认1024（2048 for x64），100万并发，就要用1000个进程、切换开销大；poll采用链表结构，没有数量限制。
	* select，poll “醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，通过回调机制节省大量CPU时间；select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，而epoll只要一次拷贝。
	* poll会随着并发增加，性能逐渐下降，epoll采用红黑树结构，性能稳定，不会随着连接数增加而降低。
	
* [《select，poll，epoll比较》](http://xingyunbaijunwei.blog.163.com/blog/static/76538067201241685556302/)
	* 在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。

* [《两种高效的服务器设计模型：Reactor和Proactor模型》](https://blog.csdn.net/u013074465/article/details/46276967)

### Epoll

* [《epoll使用详解（精髓）》](https://www.cnblogs.com/fnlingnzb-learner/p/5835573.html)

### Java NIO
* [《深入理解Java NIO》](https://www.cnblogs.com/geason/p/5774096.html)
  * NIO 是一种同步非阻塞的 IO 模型。同步是指线程不断轮询 IO 事件是否就绪，非阻塞是指线程在等待 IO 的时候，可以同时做其他任务
* [《BIO与NIO、AIO的区别》](https://blog.csdn.net/skiof007/article/details/52873421)
  * linux不支持AIO
* [《Java NIO编写Socket服务器的一个例子》](https://blog.csdn.net/xidianliuy/article/details/51612676)

### kqueue
* [《kqueue用法简介》](http://www.cnblogs.com/luminocean/p/5631336.html)

## 框架

* [《Netty原理剖析》](https://blog.csdn.net/excellentyuxiao/article/details/53390408)
	* Reactor 模式介绍。
	* Netty 是 Reactor 模式的一种实现。

* [《对于 Netty ByteBuf 的零拷贝(Zero Copy) 的理解》](https://www.cnblogs.com/xys1228/p/6088805.html)
	* 多个物理分离的buffer，通过逻辑上合并成为一个，从而避免了数据在内存之间的拷贝。

## 序列化(二进制协议)

### Hessian
* [《Hessian原理分析》](https://www.cnblogs.com/happyday56/p/4268249.html)
Binary-RPC;不仅仅是序列化

### Protobuf
* [《Protobuf协议的Java应用例子》](https://blog.csdn.net/antgan/article/details/52103966)
Goolge出品、占用空间和效率完胜其他序列化类库，如Hessian；需要编写  .proto 文件。
* [《Protocol Buffers序列化协议及应用》](https://worktile.com/tech/share/prototol-buffers)
  	* 关于协议的解释；缺点：可读性差;

* [《简单的使用 protobuf 和 protostuff》](https://blog.csdn.net/eric520zenobia/article/details/53766571)
	* protostuff 的好处是不用写 .proto 文件，Java 对象直接就可以序列化。

# 数据库
## 基础理论
### 关系数据库设计的三大范式
* [《数据库的三大范式以及五大约束》](https://www.cnblogs.com/waj6511988/p/7027127.html)
	* 第一范式：数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性；
	* 第二范式（2NF）：满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情；
	* 第三范式：必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）；

## MySQL

### 存储引擎
* [《MySQL存储引擎－－MyISAM与InnoDB区别》](https://blog.csdn.net/xifeijian/article/details/20316775)
	* Innodb 支持事务处理,外键,行级锁
	* MyISAM 性能更好,不支持事务,索引有压缩
	* select count(*) where 非主键 InnoDB会锁表
* [~~《myisam和innodb索引实现的不同》(已过时)~~](https://www.2cto.com/database/201211/172380.html)

+ [《MySQL的InnoDB索引原理详解》](https://blog.csdn.net/voidccc/article/details/40077329)
  + 主键与辅助键: InnoDB辅助键指向主键索引,需要再通过主键树查找数据; MyISAM辅助键和主键树基本无区别,都通过指针指向实际数据,固定2次查找
  + 索引类型: InnoDB使用聚簇索引,MyISAM使用非聚簇索引; 主键与数据一起,通过主键查找更快; 辅助键减少了因行移动和数据页分裂的维护成本
  + 页Page: 双向链表结构,数据页/Undo页/系统页/事务数据页
  + 记录Record: 包含Next单向链表; 非叶节点会存储最小值和最小值Page编号,用于快速定位Record

### 事务控制

+ [《InnoDB锁与MVCC》](https://blog.csdn.net/weixin_40792878/article/details/81105848)
  + InnoDB行锁要求检索条件使用索引,否则使用表锁
  + 行锁算法
    + Next-key Lock(临键锁): 默认算法,左开右闭; 范围查询且查询命中,锁住索引+表记录,不允许其他事务写入(解决幻读,实现RR)
    + Gap Lock(间隙锁): 范围查询且**未命中**,只在RR事物隔离级别存在;互不冲突
    + Record Lock(记录锁): 精确查找(唯一索引/主键索引)且命中
  + select是快照读(通过cache+undo保证事务隔离)(不包括select for update/select lock in share mode),其他语句是当前读(通过锁机制保证事务隔离)
    + mvcc: 插入事务版本小于当前版本, 删除事务版本大于当前版本
  + undo log: 原子性产物,旧数据(修改前)写入
  + redo log: 持久性产物,新数据(修改后)写入
+ [《数据库事务、锁、死锁、redo log、binlog、undo log》](https://www.cnblogs.com/xuwc/p/14006112.html)
  + binlog刷盘时机: 0(系统判断),1(每次conmmit),N(N个事务后)
  + redo log写入时机: 0(延迟写),1(实时写,实时刷),2(实时写,延迟刷)
+ [《【mysql】关于innodb中MVCC的一些理解》](https://www.cnblogs.com/chenpingzhao/p/5065316.html)
  * innodb 中 MVCC 用在 Repeatable-Read 隔离级别。
  * MVCC 会产生幻读问题（更新时异常。）
  * 通过类似乐观锁的机制,使用undo log做回滚备份,在每个涉及到修改原数据的操作时add log(update/delete)
+ [《轻松理解MYSQL MVCC 实现机制》](https://blog.csdn.net/whoamiyang/article/details/51901888)

  * 通过隐藏版本列来实现 MVCC 控制，一列记录创建时间、一列记录删除时间，这里的时间
  * 每次只操作比当前版本小（或等于）的 行。

### 优化

* [《MYSQL性能优化的最佳20+条经验》](https://www.cnblogs.com/zhouyusheng/p/8038224.html)
* [《mysql数据库死锁的产生原因及解决办法》](https://www.cnblogs.com/sivkun/p/7518540.html)
  * A/B持有独占锁且需求对方锁
  * A共享锁升级独占锁, B独占锁等待A共享锁释放
  * 多个不满足条件的update导致的全表扫描(锁表)
* [《导致索引失效的可能情况》](https://blog.csdn.net/monkey_d_feilong/article/details/52291556)
  * join中不同类型字段的连接
  * 隐式转换,如varchar2与number的比较
  * 索引列进行数学运算
* [《MySQL查询where条件的顺序对查询效率的影响》](https://www.cnblogs.com/acode/p/7489258.html)
  * 顺序无影响
  * 联合索引遵循**最左匹配原则**

+ [《MySQL 性能优化神器 Explain 使用分析》](https://segmentfault.com/a/1190000008131735)

#### 自适应哈希索引(AHI)

* [《InnoDB存储引擎——自适应哈希索引》](https://blog.csdn.net/Linux_ever/article/details/62043708)

## NoSQL

### MongoDB

* [MongoDB 教程](http://www.runoob.com/mongodb/mongodb-tutorial.html)
* [《Mongodb相对于关系型数据库的优缺点》](https://blog.csdn.net/qq_39397165/article/details/104137887)
	* 优点：弱一致性（最终一致），更能保证用户的访问速度；内置GridFS，支持大容量的存储；Schema-less 数据库，不用预先定义结构；内置Sharding；相比于其他NoSQL，第三方支持丰富；性能优越；
	* 缺点：mongodb不支持事务操作；mongodb占用空间过大；MongoDB没有如MySQL那样成熟的维护工具；

### Hbase

* [《简明 HBase 入门教程（开篇）》](http://www.thebigdata.cn/HBase/35831.html)
* [《深入学习HBase架构原理》](https://www.cnblogs.com/qiaoyihang/p/6246424.html)
* [《传统的行存储和（HBase）列存储的区别》](https://blog.csdn.net/youzhouliu/article/details/67632882)


* [《Hbase与传统数据库的区别》](https://blog.csdn.net/lifuxiangcaohui/article/details/39891099)
	* 空数据不存储，节省空间，且适用于并发。

* [《HBase Rowkey设计》](https://blog.csdn.net/u014091123/article/details/73163088)
	* rowkey 按照字典顺序排列，便于批量扫描。
	* 通过散列可以避免热点。

#### 框架


* [浅谈Phoenix在HBase中的应用](https://www.huaweicloud.com/articles/635802f721ec39063f81edb9cfc2c0fa.html)

# 搜索引擎

## Lucene
* [《Lucene入门简介》](https://www.cnblogs.com/rodge-run/p/6551152.html)

## Elasticsearch

* [《Elasticsearch学习，请先看这一篇！》](https://blog.csdn.net/laoyang360/article/details/52244917)
* [《Elasticsearch索引原理》](https://blog.csdn.net/cyony/article/details/65437708)
  * 插入数据时生成倒排索引,类似mysql InnoDB的辅助键索引
  * Term Index: Term前缀与Term Dictionary的block之间的映射关系; 通过Term前缀树定位具体Dictionary的位置,然后通过Dictionary进行二分查找
  * 使用FST压缩Term Index, 使用增量和Roaring bitmaps对posting list进行压缩
  * 联合索引: 使用跳表skip list与运算或者bitset按位与
* [《倒排索引--搜索引擎入门》](https://www.jianshu.com/p/0193dc44135b)

## Solr
* [《 Apache Solr入门教程》](https://blog.csdn.net/u011936655/article/details/51960005)
* [《elasticsearch与solr比较》](https://blog.csdn.net/convict_eva/article/details/53537837)

## sphinx 
* [《Sphinx 的介绍和原理探索》](http://blog.jobbole.com/101672/)

# 性能

## 性能优化方法论

* [《15天的性能优化工作，5方面的调优经验》](https://blog.csdn.net/huangwenyi1010/article/details/72673447?ref=myread)
	* 代码层面、业务层面、数据库层面、服务器层面、前端优化。

* [《系统性能优化的几个方面》](https://blog.csdn.net/tenglizhe/article/details/44563135)

## 容量评估
* [《联网性能与容量评估的方法论和典型案例》](https://blog.csdn.net/u012528360/article/details/70054156)
* [《互联网架构，如何进行容量设计？》](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651959542&idx=1&sn=2494bbea9a855e0e1c3ccd6d2562a600&scene=21#wechat_redirect)
	* 评估总访问量(业务/产品提供)、评估平均访问量QPS(总访问量/4w秒)、评估高峰QPS(均值QPSx比例)、评估系统(压测)、单机极限QPS

## CDN 网络

* [《CDN加速原理》](https://www.cnblogs.com/wxiaona/p/5867685.html)
* [《国内有哪些比较好的 CDN？》](https://www.zhihu.com/question/20536932)

## 性能调优

* [《九大Java性能调试工具，必备至少一款》](https://blog.csdn.net/yethyeth/article/details/73266455)


# 大数据

## 流式计算

### Storm
* [官方网站](http://storm.apache.org/)
* [《最详细的Storm入门教程》](https://blog.csdn.net/uisoul/article/details/77989927)

### Flink
* [《Flink之一 Flink基本原理介绍》](https://blog.csdn.net/lisi1129/article/details/54844919)

### Kafka Stream
* [《Kafka Stream调研：一种轻量级流计算模式》](https://yq.aliyun.com/articles/58382)

### 应用场景

例如：

* 广告相关实时统计；
* 推荐系统用户画像标签实时更新；
* 线上服务健康状况实时监测；
* 实时榜单；
* 实时数据统计。

## Hadoop

* [《用通俗易懂的话说下hadoop是什么,能做什么》](https://blog.csdn.net/houbin0912/article/details/72967178)
* [《史上最详细的Hadoop环境搭建》](http://gitbook.cn/books/5954c9600326c7705af8a92a/index.html)

### HDFS
* [《【Hadoop学习】HDFS基本原理》](https://segmentfault.com/a/1190000011575458)

### MapReduce
* [《用通俗易懂的大白话讲解Map/Reduce原理》](https://blog.csdn.net/oppo62258801/article/details/72884633)
* [《 简单的map-reduce的java例子》](https://blog.csdn.net/foye12/article/details/78358292)

### Yarn
* [《初步掌握Yarn的架构及原理》](http://www.cnblogs.com/codeOfLife/p/5492740.html)

## Spark
* [《Spark(一): 基本架构及原理》](http://www.cnblogs.com/tgzhu/p/5818374.html)
* [《子雨大数据之Spark入门教程(Python版)》](http://dblab.xmu.edu.cn/blog/1709-2/)


# 安全

## web 安全

### XSS
* [《xss攻击原理与解决方法》](https://blog.csdn.net/qq_21956483/article/details/54377947)
### CSRF
* [《CSRF原理及防范》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6412-csrf.html)

### SQL 注入

* [《SQL注入》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6413-sql-zhu-ru.html)

### Hash Dos


* [《邪恶的JAVA HASH DOS攻击》](http://www.freebuf.com/articles/web/14199.html)
	* 利用JsonObject 上传大Json，JsonObject 底层使用HashMap；不同的数据产生相同的hash值，使得构建Hash速度变慢，耗尽CPU。
* [《一种高级的DoS攻击-Hash碰撞攻击》](http://blog.it2048.cn/article_hash-collision.html )
* [《关于Hash Collision DoS漏洞：解析与解决方案》](http://www.iteye.com/news/23939/)

### 脚本注入

* [《上传文件漏洞原理及防范》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6414-shang-chuan-wen-jian-guo-lv.html)

### 漏洞扫描工具
* [《DVWA》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/6421-dvwa.html)
* [W3af](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/w3af.html)
* [OpenVAS详解](https://blog.csdn.net/xygg0801/article/details/53610640)

### 验证码

* [《验证码原理分析及实现》](https://blog.csdn.net/niaonao/article/details/51112686)

* [《详解滑动验证码的实现原理》](https://my.oschina.net/jiangbianwanghai/blog/1031031)
	* 滑动验证码是根据人在滑动滑块的响应时间，拖拽速度，时间，位置，轨迹，重试次数等来评估风险。

* [《淘宝滑动验证码研究》](https://www.cnblogs.com/xcj26/p/5242758.html)

## DDoS 防范
* [《学习手册：DDoS的攻击方式及防御手段》](http://netsecurity.51cto.com/art/201601/503799.htm)
* [《免费DDoS攻击测试工具大合集》](http://netsecurity.51cto.com/art/201406/442756.htm)

## 用户隐私信息保护

1. 用户密码非明文保存，加动态salt。
2. 身份证号，手机号如果要显示，用 “\*” 替代部分字符。
3. 联系方式在的显示与否由用户自己控制。
4. TODO

* [《个人隐私包括哪些》](https://zhidao.baidu.com/question/1988017976673661587.html)
* [《在互联网上，隐私的范围包括哪些？》](https://www.zhihu.com/question/20137108)

* [《用户密码保存》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6425-jia-mi-chang-jing-ff1a-yong-hu-mi-ma-bao-cun.html)

## 序列化漏洞
* [《Lib之过？Java反序列化漏洞通用利用分析》](https://blog.chaitin.cn/2015-11-11_java_unserialize_rce/)

## 加密解密

### 对称加密

* [《常见对称加密算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6421-chang-jian-dui-cheng-jia-mi-suan-fa.html)
	* DES(Data Encryption Standard)、3DES(Triple DES)、Blowfish、AES(Advanced Encryption Standard)
	* DES 采用 56位秘钥，Blowfish 采用1到448位变长秘钥，AES 128，192和256位长度的秘钥。
	* DES 秘钥太短（只有56位）算法目前已经被 AES 取代，并且 AES 有硬件加速，性能很好。
### 哈希算法
* [《常用的哈希算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6422-chang-jian-ha-xi-suan-fa-and-hmac.html)
	* MD5 和 SHA(Secuty Hash Algorithm)-1 已经不再安全，已被弃用; 目前 SHA-256 是比较安全的。
	
* [《基于Hash摘要签名的公网URL签名验证设计方案》](https://blog.csdn.net/zhangruhong168/article/details/78033202)

### 非对称加密
* [《常见非对称加密算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6424-chang-yong-fei-dui-cheng-jia-mi-suan-fa.html)
	
	* 公钥加密,私钥解密
		
	* RSA(取名紫发明三位科学家首字)、DSA(Digital Signature Algorithm,数字签名算法)、ECDSA(Elliptic Curve Digital Signature Algorithm,螺旋曲线加密算法)
	* 和 RSA 不同的是 DSA 仅能用于数字签名，不能进行数据加密解密，其安全性和RSA相当，但其性能要比RSA快。
	* 256位的ECC秘钥的安全性等同于3072位的RSA秘钥。
	
	  [《区块链的加密技术》](http://baijiahao.baidu.com/s?id=1578348858092033763&wfr=spider&for=pc)	


## 服务器安全
* [《Linux强化论：15步打造一个安全的Linux服务器》](http://www.freebuf.com/articles/system/121540.html)

## 数据安全

### 数据备份

TODO

## 网络隔离

### 内外网分离

TODO

### 登录跳板机
在内外环境中通过跳板机登录到线上主机。
* [《搭建简易堡垒机》](http://blog.51cto.com/zero01/2062618)

## 授权、认证

* [授权认证知识库](https://docs.authing.cn/authing/)

### RBAC 
* [《基于组织角色的权限设计》](https://www.cnblogs.com/zq8024/p/5003050.html)
* [《权限系统与RBAC模型概述》](https://www.cnblogs.com/shijiaqi1066/p/3793894.html)
* [《Spring整合Shiro做权限控制模块详细案例分析》](https://blog.csdn.net/he90227/article/details/38663553)

### OAuth2.0
* [《理解OAuth 2.0》](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)
* [《一张图搞定OAuth2.0》](https://www.cnblogs.com/flashsun/p/7424071.html)

### OIDC
* [理解 OIDC](https://docs.authing.cn/authing/advanced/oidc/li-jie-oidc-liu-cheng)

### SAML
* [理解 SAML](https://docs.authing.cn/authing/advanced/use-saml/li-jie-saml-liu-cheng)

### 双因素认证（2FA）

2FA - Two-factor authentication，用于加强登录验证

常用做法是 登录密码 + 手机验证码（或者令牌Key，类似于与网银的 USB key）

* 【《双因素认证（2FA）教程》】(http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html)

### 单点登录(SSO)

* [《单点登录原理与简单实现》](https://www.cnblogs.com/ywlaker/p/6113927.html)
* [CAS单点登录框架](https://github.com/apereo/cas)
* [使用 Authing 实现单点登录](https://docs.authing.cn/authing/quickstart/implement-sso-with-authing)

# 常用开源框架

## 开源协议

* [《开源协议的选择》](https://coderxing.gitbooks.io/architecture-evolution/chapter1/di-yi-zhang-ff1a-zhun-bei-qi-cheng/12-guan-yu-kai-yuan/123-kai-yuan-xie-yi-de-xuan-ze.html)

* [如何选择一个开源软件协议](http://choosealicense.online/)

## 日志框架

### Log4j、Log4j2
* [《log4j 详细讲解》](https://blog.csdn.net/u012422446/article/details/51199724)
* [《log4j2 实际使用详解》](https://blog.csdn.net/vbirdbest/article/details/71751835)
* [《Log4j1,Logback以及Log4j2性能测试对比》](https://my.oschina.net/OutOfMemory/blog/789267)
	* Log4J 异步日志性能优异。 

### Logback
* [《最全LogBack 详解、含java案例和配置说明》](https://blog.csdn.net/rulon147/article/details/52620541)

## ORM

* [《ORM框架使用优缺点》](https://blog.csdn.net/sinat_34093604/article/details/53082000)
	* 主要目的是为了提高开发效率。 

#### MyBatis

* [《mybatis缓存机制详解》](https://www.cnblogs.com/winclpt/articles/7511672.html)
	* 一级缓存是SqlSession级别的缓存，缓存的数据只在SqlSession内有效
	* 二级缓存是mapper级别的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的；使用 LRU 机制清理缓存，通过 cacheEnabled 参数开启。  

* [《MyBatis学习之代码生成器Generator》](https://blog.csdn.net/baidu_32877851/article/details/53959268)

## 网络框架

TODO

## Web 框架

### Spring 家族
#### Spring

* [Spring 简明教程](https://www.w3cschool.cn/wkspring/)
* [《Spring容器启动流程》](https://blog.csdn.net/qq_35190492/article/details/110383213)
  * 上下文`AbstractApplicationContext`：AnnotationConfigApplicationContext（java-config），ClassPathXmlApplicationContext（xml文件）
  * 创建IoC容器
    * new容器
      * 实例化默认BeanFactory`DefaultListableBeanFactory`
      * 实例化注解读取器`AnnotatedBeanDefinitionReader`：添加BeanFactory后置处理器x2，Bean后置处理器x2，普通组件x1
      * 实例化指定目录扫描器`ClassPathBeanDefinitionScanner`
    * 注入Spring配置`doRegisterBean()`：生成SpringConfig对应BeanDefinition，并注册到容器
    * 刷新容器↓
  * 刷新容器`refresh()`
    + 预处理->获取BeanFactory->预处理BeanFactory->子类处理->执行BeanFactory后置处理器->注册Bean后置处理器->国际化->事件派发器->子类`refresh()`->注册监听器->初始化非内置单例Bean->完成初始化
    + 预处理BeanFactory：添加组件:Bean后置处理器x2，自动装配器x4，环境组件x3
    + 注册Bean后置处理器：后置处理器先添加进list，排序后再进行处理器对象创建->添加至容器
    + 完成初始化：清理缓存，生命周期处理器，发布容器刷新完成事件
* [《Spring Bean初始化过程》](https://www.huangchaoyu.com/2020/06/15/Spring-Bean%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/)
  * Bean初始化流程
    * IOC容器将Bean解析成BeanDefinition对象（包含如ClassName、single、scope、lazy等属性），并放入BeanDefinitionMap中，提取ClassName放入beanNames列表
    * 遍历beanNames通过反射实例化Bean，进行初始化；分为FactoryBean和普通Bean
    * 反射后通过空构造器创建Bean（完成实例化，加入二级缓存）->循环依赖处理->进行依赖注入->初始化：回调各种Aware->回调初始化方法（完成初始化）
  * 通过BeanPostProcessor.postProcessBeforeInstantiation/postProcessAfterInstantiation 执行Bean实例化前后操作
  * 通过BeanPostProcessor.postProcessBeforeInitialization/postProcessAfterInitialization 执行Bean初始化前后操作
    * 通过InitializingBean.afterPropertiesSet进行自定义属性复制
  * 解决循环依赖：通过将三级缓存创建对象升级到二级缓存完成初始化
    * Spring三级缓存：完成创建单例对象；实例化未初始化对象；待实例化对象的工厂
* [《Spring系列.AOP原理简析》](https://www.cnblogs.com/54chensongxia/p/13141362.html)
  * `@EnableAspectJAutoProxy`注解通过AopConfigUtils这个工具类注册`AnnotationAwareAspectJAutoProxyCreator`这个类，这个类实现了`InstantiationAwareBeanPostProcessor`接口，所以会在Bean实例化前后对Bean做一系列额外的操作；
  * `AnnotationAwareAspectJAutoProxyCreator`的postProcessAfterInitialization中会找出所有和当前Bean相关的Advice，如果找到就创建相应的动态代理类，如果找不到就不生成，返回原始类。

#### Spring Boot

* [官方网站](http://projects.spring.io/spring-boot/)
* [《Spring Boot基础教程》](http://blog.didispace.com/Spring-Boot%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/)
* [《SpringBoot自动配置原理》](https://segmentfault.com/a/1190000018011535)
  * `@SpringBootApplication`->`@EnableAutoConfiguration`：开启自动配置
  * `@AutoConfigurationPackage`：扫描非Spring注解（如JPA：@Entity）
  * `AutoConfigurationImportSelector`->通过SpringFactoriesLoader加载配置factories文件
    * Spring启动的时候会扫描所有jar路径下的`META-INF/spring.factories`，将其文件包装成Properties对象
    * 从Properties对象获取到key值为`EnableAutoConfiguration`的数据，然后添加到容器里边

#### Spring Cloud

* [Spring Boot 中文索引站](http://springboot.fun/)
* [Spring Cloud 中文文档](https://springcloud.cc/)
* [《Spring Cloud基础教程》](http://blog.didispace.com/Spring-Cloud%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/)
* [《SpringCloud概述》](https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484335&idx=1&sn=a871bf871fcaffda0be40e1388a69d7d)
  * Eureka：服务注册与发现
    * 服务续约：在注册完服务之后，服务提供者会维护一个心跳用来持续告诉Eureka Server:  "我还活着 ”
    * 失效剔除：默认每隔一段时间（默认为60秒） 将当前清单中超时（默认为90秒）没有续约的服务剔除出去
    * 自我保护：会统计心跳失败的比例在15分钟之内是否低于85%(通常由于网络不稳定导致)。 将当前的实例注册信息保护起来，让这些实例不会过期，尽可能保护这些注册信息(HA实现)
  * Ribbon：客户端负载均衡
  * Hystrix：提供几个熔断关键参数：滑动窗口大小（20）、熔断器开关间隔（5s）、错误率（50%）
    * 每当20个请求中，有50%失败时，熔断器就会打开，此时再调用此服务，将会直接返回失败，不再调远程服务。
    * 直到5s钟之后，重新检测该触发条件，判断是否把熔断器关闭，或者继续打开。
  * Feign：声明式、模板化的HTTP客户端，Ribbon+Hystrix+RestTemplate，简化服务调用
  * Zuul：将自身注册为Eureka服务治理下的应用，同时从Eureka中获得了所有其他微服务的实例信息
    * 前置过滤，拦截，校验
  * Config：统一配置文件管理，动态刷新配置可以通过Bus消息总线来实现

## 工具框架

* [《Apache Commons 工具类介绍及简单使用》](https://www.cnblogs.com/crazylqy/p/4872236.html)
* [《Google guava 中文教程》](http://ifeve.com/google-guava/)


# 分布式设计

## 扩展性设计

* [《架构师不可不知的十大可扩展架构》](https://my.oschina.net/zhanghaiyang/blog/606686)
	* 总结下来，通用的套路就是分布、缓存及异步处理。 

* [《可扩展性设计之数据切分》](https://yq.aliyun.com/articles/38119)
	* 水平切分+垂直切分
	* 利用中间件进行分片如，MySQL Proxy。
	* 利用分片策略进行切分，如按照ID取模。 
* [《说说如何实现可扩展性的大型网站架构》](https://blog.csdn.net/deniro_li/article/details/78458306)
	* 分布式服务+消息队列。

* [《大型网站技术架构（七）--网站的可扩展性架构》](https://blog.csdn.net/chaofanwei/article/details/29191073)

## 稳定性 & 高可用

* [《系统设计：关于高可用系统的一些技术方案》](https://blog.csdn.net/hustspy1990/article/details/78008324)
	* 可扩展：水平扩展、垂直扩展。 通过冗余部署，避免单点故障。
	* 隔离：避免单一业务占用全部资源。避免业务之间的相互影响 2. 机房隔离避免单点故障。
	* 解耦：降低维护成本，降低耦合风险。减少依赖，减少相互间的影响。
	* 限流：滑动窗口计数法(Hystrix)、漏桶算法(可Redis List实现)、令牌桶算法(Guava RateLimiter)等算法。遇到突发流量时，保证系统稳定。
	* 降级：紧急情况下释放非核心功能的资源。牺牲非核心业务，保证核心业务的高可用。
	* 熔断：异常情况超出阈值进入熔断状态，快速失败。减少不稳定的外部依赖对核心服务的影响。
	* 自动化测试：通过完善的测试，减少发布引起的故障。
	* 灰度发布：灰度发布是速度与安全性作为妥协，能够有效减少发布故障。


* [《关于高可用的系统》](https://coolshell.cn/articles/17459.html)
	* 设计原则：数据不丢(持久化)；服务高可用(服务副本)；绝对的100%高可用很难，目标是做到尽可能多的9，如99.999%（全年累计只有5分钟）。	 
* [《谈谈高并发系统的限流》](https://www.cnblogs.com/haoxinyue/p/6792309.html)
  * 计数器：通过滑动窗口计数器，控制单位时间内的请求次数，简单粗暴。
  * 漏桶算法：固定容量的漏桶，漏桶满了就丢弃请求，比较常用。
  * 令牌桶算法：固定容量的令牌桶，按照一定速率添加令牌，处理请求前需要拿到令牌，拿不到令牌则丢弃请求，或进入丢队列，可以通过控制添加令牌的速率，来控制整体速度。Guava 中的 RateLimiter 是令牌桶的实现。
  * Nginx 限流：通过 `limit_req` 等模块限制并发连接数。

### 硬件负载均衡

* [《转！！负载均衡器技术Nginx和F5的优缺点对比》](https://www.cnblogs.com/wuyun-blog/p/6186198.html)
	* 主要是和F5对比。

* [《软/硬件负载均衡产品 你知多少？》](https://www.cnblogs.com/lcword/p/5773296.html)

### 软件负载均衡

* [《几种负载均衡算法》](https://www.cnblogs.com/tianzhiliang/articles/2317808.html)
	轮寻、权重、负载、最少连接、QoS
* [《DNS负载均衡》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/611-dns-fang-shi.html)
	* 配置简单，更新速度慢。 
* [《Nginx负载均衡》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/613-nginx-fu-zai-jun-heng.html)
	* 简单轻量、学习成本低；主要适用于web应用。

*  [《借助LVS+Keepalived实现负载均衡 》](https://www.cnblogs.com/edisonchou/p/4281978.html)
	* 配置比较负载、只支持到4层，性能较高。

* [《HAProxy用法详解 全网最详细中文文档》](http://www.ttlsa.com/linux/haproxy-study-tutorial/)
	* 支持到七层（比如HTTP）、功能比较全面，性能也不错。

* [《Haproxy+Keepalived+MySQL实现读均衡负载》](http://blog.itpub.net/25704976/viewspace-1319781/)
	* 主要是用户读请求的负载均衡。

* [《rabbitmq+haproxy+keepalived实现高可用集群搭建》](https://www.cnblogs.com/lylife/p/5584019.html)

### 跨机房容灾

* [《“异地多活”多机房部署经验谈》](http://dc.idcquan.com/ywgl/71559.shtml)
	* 通过自研中间件进行数据同步。 

* [《异地多活（异地双活）实践经验》](https://blog.csdn.net/jeffreynicole/article/details/48135093)
	* 注意延迟问题，多次跨机房调用会将延时放大数倍。
	* 建房间专线很大概率会出现问题，做好运维和程序层面的容错。
	* 不能依赖于程序端数据双写，要有自动同步方案。 
	* 数据永不在高延迟和较差网络质量下，考虑同步质量问题。
	* 核心业务和次要业务分而治之，甚至只考虑核心业务。
	* 异地多活监控部署、测试也要跟上。
	* 业务允许的情况下考虑用户分区，尤其是游戏、邮箱业务。
	* 控制跨机房消息体大小，越小越好。
	* 考虑使用docker容器虚拟化技术，提高动态调度能力。

* [容灾技术及建设经验介绍](https://blog.csdn.net/yoara/article/details/38013751)


### 容灾演练流程

* [《依赖治理、灰度发布、故障演练，阿里电商故障演练系统的设计与实战经验》](https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=2650996320&idx=1&sn=0ed3be190bbee4a9277886ef88cbb2e5)
	* 常见故障画像
	* 案例：预案有效性、预案有效性、故障复现、架构容灾测试、参数调优、参数调优、故障突袭、联合演练。

### 平滑启动

* 平滑重启应用思路
1.端流量（如vip层）、2. flush 数据(如果有)、3, 重启应用

* [《JVM安全退出（如何优雅的关闭java服务）》](https://blog.csdn.net/u011001084/article/details/73480432)
推荐推出方式：System.exit，Kill SIGTERM；不推荐 kill-9；用 Runtime.addShutdownHook 注册钩子。
* [《常见Java应用如何优雅关闭》](http://ju.outofmemory.cn/entry/337235)
Java、Spring、Dubbo 优雅关闭方式: 注册ShutdownHook。

## 数据库扩展

### 读写分离模式

* [《Mysql主从方案的实现》](https://www.cnblogs.com/houdj/p/6563771.html)
* [《搭建MySQL主从复制经典架构》](https://www.cnblogs.com/edisonchou/p/4133148.html)
* [《Haproxy+多台MySQL从服务器(Slave) 实现负载均衡》](https://blog.csdn.net/nimasike/article/details/48048341)

* [《DRBD+Heartbeat+Mysql高可用读写分离架构》](https://www.cnblogs.com/zhangsubai/p/6801764.html)
	* DRDB 进行磁盘复制，避免单点问题。

* [《MySQL Cluster 方式》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/62-ke-kuo-zhan-de-shu-ju-ku-jia-gou/621-gao-ke-yong-mysql-de-ji-zhong-fang-an/6214-mysql-cluster-fang-an.html)

### 分片模式
* [《分库分表需要考虑的问题及方案》](https://cloud.tencent.com/developer/article/1519801)
	* 中间件： 轻量级：sharding-jdbc、TSharding；重量级：Atlas、MyCAT、Vitess等。
	* 问题：事务、Join、迁移、扩容、ID、分页等。
	* 事务补偿：对数据进行对帐检查;基于日志进行比对;定期同标准数据来源进行同步等。
	* 分库策略：数值范围；取模；日期等。
	* 分库数量：通常 MySQL 单库 5千万条、Oracle 单库一亿条需要分库。 

* [《MySql分表和表分区详解》](https://www.2cto.com/database/201503/380348.html)
	* 分区：是MySQL内部机制，对客户端透明，数据存储在不同文件中，表面上看是同一个表。
	* 分表：物理上创建不同的表、客户端需要管理分表路由。

## 服务治理
###  服务注册与发现

* [《永不失联！如何实现微服务架构中的服务发现？》](https://blog.csdn.net/jiaolongdy/article/details/51188798)
  * 客户端服务发现模式：客户端直接查询注册表，同时自己负责负载均衡。Eureka 采用这种方式。
  * 服务器端服务发现模式：客户端通过负载均衡查询服务实例。
* [《SpringCloud服务注册中心比较:Consul vs Zookeeper vs Etcd vs Eureka》](https://luyiisme.github.io/2017/04/22/spring-cloud-service-discovery-products/?utm_source=tuicool&utm_medium=referral)
  * CAP支持：Consul（CP）、zookeeper（cp）、etcd（cp） 、eureka（ap）
* [《用CAP理论来解释各个注册中心的区别》](https://cloud.tencent.com/developer/article/1616347)
  * eureka无leader使用同级节点,可能出现查询不一致
  * ZK使用PAXOS算法保证一致性,Consul和ETCD使用Raft算法


## 分布式一致

### 理论

* [《从分布式一致性谈到CAP理论、BASE理论》](http://www.cnblogs.com/szlbm/p/5588543.html)
	* 一致性分类：强一致(立即一致)；弱一致(可在单位时间内实现一致，比如秒级)；最终一致(弱一致的一种，一定时间内最终一致)
	* CAP：一致性、可用性、分区容错性(网络故障引起)
	* BASE：Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）
	* BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。
* [《传统事务与柔性事务》](https://www.jianshu.com/p/ab1a1c6b08a1)
  * 基于BASE理论：基本可用、柔性状态、最终一致。
  * 解决方案：记录日志+补偿（正向补充或者回滚）、消息重试(要求程序要幂等)；“无锁设计”、采用乐观锁机制。
* [《关于分布式事务、两阶段提交协议、三阶提交协议》](https://www.hollischuang.com/archives/681)
  * 2PC:准备+提交
  * 3PC:准备+预提交+提交,超时机制+超时默认提交

### 分布式锁

* [《分布式锁的几种实现方式》](http://www.hollischuang.com/archives/1716)
	* 基于数据库的分布式锁：优点：操作简单、容易理解。缺点：存在单点问题、数据库性能够开销较大、不可重入；
	* 基于缓存的分布式锁：优点：非阻塞、性能好。缺点：操作不好容易造成锁无法释放的情况。
	* Zookeeper 分布式锁：通过有序临时节点实现锁机制，自己对应的节点需要最小，则被认为是获得了锁。优点：集群可以透明解决单点问题，避免锁不被释放问题，同时锁可以重入。缺点：性能不如缓存方式，吞吐量会随着zk集群规模变大而下降。
* [《基于Zookeeper的分布式锁》](https://blog.csdn.net/fuzhongmin05/article/details/95102116)
	* 清楚的原理描述 + Java 代码示例。 

* [《jedisLock—redis分布式锁实现》](https://www.cnblogs.com/0201zcr/p/5942748.html)
	* 基于 setnx(set if ont exists)，有则返回false，否则返回true。并支持过期时间。

* [《Memcached 和 Redis 分布式锁方案》](https://blog.csdn.net/albertfly/article/details/77412333)
	* 利用 memcached 的 add（有别于set）操作，当key存在时，返回false。

### 算法

#### PAXOS算法

+ [论文: Leslie Lamport-《The PartTime Parliament》-1990](http://research.microsoft.com/en-us/um/people/lamport/pubs/lamport-paxos.pdf)
+ [论文: Nancy Lynch-《Revisiting the Paxos Algorithm》-1996](http://research.microsoft.com/en-us/um/people/blampson/60-PaxosAlgorithm/Acrobat.pdf)
+ [论文: Leslie Lamport-《Paxos Made Simple》-2001](https://www.microsoft.com/en-us/research/publication/paxos-made-simple/)

* [《分布式系列文章——Paxos算法原理与推导》](https://www.cnblogs.com/linbingdong/p/6253479.html)
  * 阶段一
    * Proposer选择一个**提案编号N**，然后向**半数以上**的Acceptor发送编号为N的**Prepare请求**
    * 如果一个Acceptor收到一个编号为N的Prepare请求，且N**大于**该Acceptor已经**响应过的**所有**Prepare请求**的编号，那么它就会将它已经**接受过的编号最大的提案（如果有的话）**作为响应反馈给Proposer，同时该Acceptor承诺**不再接受**任何**编号小于N的提案**
  * 阶段二
    * 如果Proposer收到**半数以上**Acceptor对其发出的编号为N的Prepare请求的**响应**，那么它就会发送一个针对**[N,V]提案**的**Accept请求**给**半数以上**的Acceptor。注意：V就是收到的**响应**中**编号最大的提案的value**，如果响应中**不包含任何提案**，那么V就由Proposer**自己决定**
    * 如果Acceptor收到一个针对编号为N的提案的Accept请求，只要该Acceptor**没有**对编号**大于N**的**Prepare请求**做出过**响应**，它就**接受该提案**
* [《Paxos-->Fast Paxos-->Zookeeper分析》](https://blog.csdn.net/u010039929/article/details/70171672)

#### Zab协议
* [《Zab：Zookeeper 中的分布式一致性协议介绍》](https://www.jianshu.com/p/fb527a64deee)
* [《【分布式】Zookeeper与Paxos》](https://www.cnblogs.com/leesf456/p/6012777.html)
  * 消息广播: 使用TCP进行通信,保证事务顺序,事务ID=ZXID; 新节点进入**数据恢复模式**,从Leader中同步数据
  * 崩溃恢复: 选举
  * 基本特性=>选举使用所有机器最高事务编号(ZXID)的原因
    * **确保丢弃那些只在Leader服务器上被提出的事务**
    * **确保那些已经在Leader服务器上提交的事务最终被所有服务器都提交**
  * 数据同步
    * 对象: 新加入节点; 选举完成未提交所有事务的节点
    * 操作: 重新发送全部Proposal+Commit,完成后再加入可用节点列表(未同步完成节点不对外提供服务)
  * ZXID=32位epoch编号+32位计数器,选举后重置低32位,将新Leader的最大ZXID的epoch+1作为新高32位
    * 只在本机提交的原Leader因为epoch较小肯定无法成为新Leader=>完成无效Proposal抛弃

#### Raft算法
* [《Raft 为什么是更易理解的分布式一致性算法》](http://www.cnblogs.com/mindwind/p/5231986.html)
	* 三种角色：Leader（领袖）、Follower（群众）、Candidate（候选人）
	* 通过**随机等待**的方式发出投票, 其他候选者还在等待中只能投票他人, 得票多的获胜。
	* 网络分区脑裂: 旧Leader通过较新Term降级为Follower

#### Gossip
* [《Gossip算法》](https://blog.csdn.net/chen77716/article/details/6275762)
  * 最终一致性算法,去中心化(无Leader);缺点: 冗余通信=>额外资源消耗(带宽/CPU)
  * 传播速率分类: 反熵(Anti-Entropy,固定概率所有数据), 谣言传播(Rumor-Mongering,仅新到达的数据)
  * 反熵协调机制: 精确协调(每个节点一个version), 整体协调(多个节点使用一个version)

### 幂等

* [《分布式系统---幂等性设计》](https://www.cnblogs.com/wxgblogs/p/6639272.html)
	* 幂等特性的作用：该资源具备幂等性，请求方无需担心重复调用会产生错误。
	* 常见保证幂等的手段：MVCC（类似于乐观锁）、去重表(唯一索引)、悲观锁、一次性token、序列号方式。 

### 方案
* [《保证分布式系统数据一致性的6种方案》](https://cloud.tencent.com/developer/article/1041507)

* [《利用zookeeper实现分布式leader节点选举》](https://blog.csdn.net/johnson_moon/article/details/78809995)

## 分布式文件系统

* [说说分布式文件存储系统-基本架构](https://zhuanlan.zhihu.com/p/27666295) ？
* [《各种分布式文件系统的比较》](https://blog.csdn.net/gatieme/article/details/44982961) ？
  * HDFS：大批量数据读写，用于高吞吐量的场景，不适合小文件。
  * FastDFS：轻量级、适合小文件。

## 唯一ID 生成

### 全局唯一ID
* [《高并发分布式系统中生成全局唯一Id汇总》](https://www.cnblogs.com/baiwa/p/5318432.html)
	* Twitter 方案（Snowflake 算法）：41位时间戳+10位机器标识（比如IP，服务器名称等）+12位序列号(本地计数器)
	* Flicker 方案：MySQL自增ID + "REPLACE INTO XXX:SELECT LAST_INSERT_ID();" 
	* UUID：缺点，无序，字符串过长，占用空间，影响检索性能。
	* MongoDB 方案：利用 ObjectId。缺点：不能自增。

* [《TDDL 在分布式下的SEQUENCE原理》](https://blog.csdn.net/hdu09075340/article/details/79103851)
	* 在数据库中创建 sequence 表，用于记录，当前已被占用的id最大值。
	* 每台客户端主机取一个id区间（比如 1000~2000）缓存在本地，并更新 sequence 表中的id最大值记录。
	* 客户端主机之间取不同的id区间，用完再取，使用乐观锁机制控制并发。

## 一致性Hash算法

* [《一致性哈希算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/631-yi-zhi-xing-ha-xi.html)

## 高可用

## 常见分布式问题

#### 缓存穿透、击穿、雪崩

> 穿透：无效key
>
> 击穿：热点key失效
>
> 雪崩：缓存失效；批量key失效

* [《防雪崩利器：熔断器 Hystrix 的原理与使用》](https://segmentfault.com/a/1190000005988895)
  * 雪崩效应原因：硬件故障、硬件故障、程序Bug、重试加大流量、用户大量请求。 
  * 雪崩的对策：限流、改进缓存模式(缓存预加载、同步调用改异步)、自动扩容、降级。
  * Hystrix设计原则：
    * 资源隔离：Hystrix通过将每个依赖服务分配独立的线程池进行资源隔离, 从而避免服务雪崩。
    * 熔断开关：服务的健康状况 = 请求失败数 / 请求总数，通过阈值设定和滑动窗口控制开关。
    * 命令模式：通过继承 HystrixCommand 来包装服务调用逻辑。 
* [《缓存穿透，缓存击穿，缓存雪崩解决方案分析》](https://blog.csdn.net/zeb_perfect/article/details/54135506)
  * 缓存穿透: 布隆过滤器拦截不存在的访问; 缓存空结果(较短有效期)
  * 缓存击穿: 使用互斥锁实现单线程load db refresh cache; 提前refresh; 永不过期; Hystrix保护
  * 缓存雪崩: (一定范围内)随机失效时间
* [《缓存击穿、失效以及热点key问题》](https://www.jianshu.com/p/d5a3668d4dad) 
  * 主要策略：失效瞬间：单机使用锁；使用分布式锁；不过期；
  * 热点数据：热点数据单独存储；使用本地缓存；分成多个子key；

#### 假死、脑裂（Split-Brain）

> 假死场景：主节点临时宕机，从节点重新选举主节点，原主节点恢复后集群有2个主节点
>
> 脑裂场景：由于集群网络通信导致的节点间无法互相访问，从而出现2个提供服务的网络分区
>
> 主要解决方案
>
> 1. 法定人数（Quorums）: 比如3个节点的集群，Quorums = 2, 也就是说集群可以容忍1个节点失效，这时候还能选举出1个lead，集群还可用。比如4个节点的集群，它的Quorums = 3，Quorums要超过3，相当于集群的容忍度还是1，如果2个节点失效，那么整个集群还是无效的。这是zookeeper防止"脑裂"默认采用的方法。
> 2. 冗余通信（Redundant communications）：集群中采用多种通信方式，防止一种通信方式失效导致集群中的节点无法通信。
> 3. 共享资源（Fencing）：比如能看到共享资源就表示在集群中，能够获得共享资源的锁的就是Leader，看不到共享资源的，就不在集群中。
> 4. 仲裁机制方式：由第三方决定，如设置参考IP（如网关IP），当心跳线完全断开时，2个节点都各自ping一下 参考IP，不通则表明断点就出在本端
> 5. 启动磁盘锁定方式：正在服务的一方只在发现心跳线全部断开（察觉不到对端）时才启用磁盘锁

+ [《RabbitMQ脑裂问题解决方案调查》](https://www.cnblogs.com/liyongsan/p/9640361.html)
  + 法定人数方案，提供配置设置网络分区时策略
  + 自动处理：ignore（忽视），autoheal（连接数较少分区节点重启），pause_minority（少数派节点分区暂停），pause-if-all-down（所有节点全挂时关闭集群）
  + 人工恢复：重启集群；选择受信分区重启其他分区，然后再重启受信分区
+ [《Zookeeper集群"脑裂"问题》](https://www.cnblogs.com/kevingrace/p/12433503.html)
  + Zookeeper解决方案：法定人数，节点个数为奇数个，选举过半机制
+ Redis方案：法定人数，提供参数（min-slaves-to-write）设置连接到Master的最小Slave数量
+ HDFS方案：共享资源

# 设计思想 & 开发模式

## DDD(Domain-driven Design - 领域驱动设计)

* [《领域驱动设计的基础知识总结》](https://www.cnblogs.com/butterfly100/p/7827870.html)
  * 领域（Doamin）本质上就是问题域，比如一个电商系统，一个论坛系统等。
  * 限界上下文（Bounded Context）：阐述子域之间的关系，可以简单理解成一个子系统或组件模块。
  * 领域模型（Domain Model）：DDD的核心是建立（用通用描述语言、工具—领域通用语言）正确的领域模型；反应业务需求的本质，包括实体和过程；其贯穿软件分析、设计、开发 的整个过程；常用表达领域模型的方式：图、代码或文字；
  * 领域通用语言：领域专家、开发设计人员都能理解的语言或工具。
  * 经典分层架构：用户界面/展示层、应用层、领域层、基础设施层，是四层架构模式。
  * 使用的模式：
    * 关联尽量少，尽量单项，尽量降低整体复杂度。
    * 实体（Entity）：领域中的唯一标示，一个实体的属性尽量少，少则清晰。
    * 值对象（Value Object）：没有唯一标识，且属性值不可变，小而简单的对象，比如Date。
    * 领域服务（Domain Service）： 协调多个领域对象，只有方法没有状态(不存数据)；可以分为应用层服务，领域层服务、基础层服务。
    * 聚合及聚合根（Aggregate，Aggregate Root）：聚合定义了一组具有内聚关系的相关对象的集合；聚合根是对聚合引用的唯一元素；当修改一个聚合时，必须在**事务**级别；
    * 工厂（Factory）：类似于设计模式中的工厂模式。
    * 仓储（Repository）：持久化到DB，管理对象，且只对聚合设计仓储。

* [《领域驱动设计(DDD)实现之路》](http://www.cnblogs.com/Leo_wl/p/3866629.html)
	* 聚合：比如一辆汽车（Car）包含了引擎（Engine）、车轮（Wheel）和油箱（Tank）等组件，缺一不可。

* [《领域驱动设计系列（2）浅析VO、DTO、DO、PO的概念、区别和用处》](https://www.cnblogs.com/Sabre/p/7760676.html)


### 命令查询职责分离(CQRS)

CQRS — Command Query Responsibility Seperation

* [《领域驱动设计系列 (六)：CQRS》](https://www.cnblogs.com/cnblogsfans/p/4551990.html)
	* 核心思想：读写分离（查询和更新在不同的方法中），不同的流程只是不同的设计方式，CQ代码分离，分布式环境中会有明显体现（有冗余数据的情况下），目的是为了高性能。

* [《DDD CQRS架构和传统架构的优缺点比较》](https://developer.aliyun.com/article/53542)
	* 最终一致的设计理念；依赖于高可用消息中间件。
	
* [《CQRS架构简介》](http://www.cnblogs.com/netfocus/p/4055346.html)
	* 一个实现 CQRS 的抽象案例。

* [《深度长文：我对CQRS/EventSourcing架构的思考》](http://www.uml.org.cn/zjjs/201609221.asp)
	* CQRS 模式分析 + 12306 抢票案例

### 贫血，充血模型

* [《贫血，充血模型的解释以及一些经验》](https://kb.cnblogs.com/page/520743/)
	* 失血模型：实体定义中完全没有业务逻辑，通过外部Service进行关联。
	* 贫血模型：持久化无关逻辑放到实体中,其他放到service中; 优点：各层单项依赖，结构清楚，易于维护；缺点：不符合OO思想，相比于充血模式，Service层较为厚重；
	* 充血模型：和贫血模型类似，区别在于如何划分业务逻辑。优点：Service层比较薄，只充当Facade的角色，不和DAO打交道、复合OO思想；缺点：非单项依赖，DO和DAO之间双向依赖、和Service层的逻辑划分容易造成混乱。
	* 肿胀模式：是一种极端情况，取消Service层、全部业务逻辑放在DO中；优点：符合OO思想、简化了分层；缺点：暴露信息过多、很多非DO逻辑也会强行并入DO。
## Actor 模式

TODO

## 响应式编程

### Reactor
TODO
### RxJava
TODO
### Vert.x
TODO

## DODAF2.0

* [《DODAF2.0方法论》](http://www.360doc.com/content/16/0627/19/33945750_571201779.shtml)
* [《DODAF2.0之能力视角如何落地》](http://blog.51cto.com/xiaoyong/1553164)

## Serverless

无需过多关系服务器的服务架构理念。

* [《什么是Serverless无服务器架构？》](http://www.jdon.com/soa/serverless.html)
	* Serverless 不代表出去服务器，而是去除对服务器运行状态的关心。
	* Serverless 代表一思维方式的转变，从“构建一套服务在一台服务器上，对对个事件进行响应”转变为“构建一个服务，来响应一个事件”。
	* Serverless 不代表某个具体的框架。

* [《如何理解Serverless？》](http://www.infoq.com/cn/news/2017/10/how-to-understand-serverless)
	* 依赖于 Baas （(Mobile) Backend as a Service） 和 Faas （Functions as a service）



## Service Mesh

* [《什么是Service Mesh？》](https://time.geekbang.org/article/2355)
  * 基础设施层, 用于服务通信, 处于TCP/IP上的抽象层
  * 常用于云原生: Docker+Istio+Kubernetes
* [《初识 Service Mesh》](https://www.jianshu.com/p/e23e3e74538e)


# 项目管理

## 架构评审
* [《架构设计之如何评审架构设计说明书》](https://www.cnblogs.com/swordxia/p/4545448.html)
* [《人人都是架构师：非功能性需求》](https://blog.csdn.net/wireless_com/article/details/45935591)

## 重构

* [《架构之重构的12条军规》](http://www.infoq.com/cn/articles/architect-12-rules-complete/)

## 代码规范

* [《阿里巴巴Java开发手册》](https://github.com/alibaba/p3c)

## 代码 Review


制度还是制度!
另外，每个公司需要根据自己的需求和目标制定自己的 check list

* [《为什么你做不好 Code Review？》](http://www.sohu.com/a/229745352_181657)
	* 代码 review 做的好，在于制度建设。

* [《从零开始Code Review》](https://blog.csdn.net/uxyheaven/article/details/49773619)

* [《Code Review Checklist》](https://www.cnblogs.com/zuoping/p/5477047.html)
* [《Java Code Review Checklist》](https://dzone.com/articles/java-code-review-checklist)

* [《如何用 gitlab 做 code review》](https://blog.csdn.net/legend0011/article/details/45585575)

## RUP
* [《运用RUP 4+1视图方法进行软件架构设计》](https://blog.csdn.net/apanious/article/details/51011946)

## 看板管理
* [《说说看板在项目中的应用》](https://blog.csdn.net/tkchen/article/details/51637643)

## SCRUM

SCRUM - 争球

* 3个角色:Product Owner(PO) 产品负责人;Scrum Master（SM），推动Scrum执行;Team 开发团队。
* 3个工件：Product Backlog 产品TODOLIST，含优先级;Sprint Backlog 功能开发 TODO LIST；燃尽图；
* 五个价值观：专注、勇气、公开、承诺、尊重。


* [《敏捷项目管理流程-Scrum框架最全总结！》](https://blog.csdn.net/inny100_100/article/details/54633757)

* [《敏捷其实很简单3---敏捷方法之scrum》](https://blog.csdn.net/superkunkun/article/details/52951142)

## 敏捷开发

TODO

## 极限编程（XP）

XP - eXtreme Programming

* [《主流敏捷开发方法：极限编程XP》](http://www.woshipm.com/pmd/406917.html)
	* 是一种指导开发人员的方法论。
	* 4大价值：
		* 沟通：鼓励口头沟通，提高效率。
		* 简单：够用就好。
		* 反馈：及时反馈、通知相关人。
		* 勇气：提倡拥抱变化，敢于重构。
		
	* 5个原则：快速反馈、简单性假设、逐步修改、提倡更改（小步快跑）、优质工作（保证质量的前提下保证小步快跑）。
	* 5个工作：阶段性冲刺；冲刺计划会议；每日站立会议；冲刺后review；回顾会议。

## 结对编程

边写码，边review。能够增强代码质量、减少bug。

* [《结对编程》](http://www.baike.com/wiki/%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B)

## PDCA 循环质量管理

P——PLAN 策划，D——DO 实施，C——CHECK 检查，A——ACT 改进

* [《PDCA》](http://www.baike.com/wiki/PDCA)

## FMEA管理模式

TODO

# 通用业务术语

TODO

# 技术趋势

TODO

# 政策、法规

## 法律

* [《中华人民共和国网络安全法》](https://baike.baidu.com/item/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B3%95/16843044)
  
* 2016年11月7日发布，自2017年6月1日起施行
  
* [《个人信息保护法》](https://baike.baidu.com/item/个人信息保护法/8343360)
  
* 个人信息保护法是一部保护个人信息的法律条款，现尚在制订中，2019全国两会信息安全相关提案中，有政协委员呼吁关注大数据时代隐私保护，加速立法。
  
* [《最高人民法院、最高人民检察院关于办理侵犯公民个人信息刑事案件适用法律若干问题的解释》](https://baike.baidu.com/item/最高人民法院、最高人民检察院关于办理侵犯公民个人信息刑事案件适用法律若干问题的解释/20497481)
  * 《解释》共十三条，自2017年6月1日起施行
  > * 1、对于行踪轨迹信息、通信内容、征信信息、财产信息，非法获取、出售或者提供50条以上即算“情节严重”；
  > * 2、对于住宿信息、通信记录、健康生理信息、交易信息等其他可能影响人身、财产安全的公民个人信息，标准则是 500条以上；
  > * 3、对于其他公民个人信息，标准为 5000条以上。

* [《中华人民共和国电子商务法》](https://baike.baidu.com/item/中华人民共和国电子商务法/16467544)
  * 2018年8月31日，十三届全国人大常委会第五次会议表决通过《电子商务法》，自2019年1月1日起施行
  * [解读电子商务法（一）什么是电商](https://v.youku.com/v_show/id_XNDAzNjAyNDM0MA==.html)
  * [解读电子商务法（二）电商经营者](https://v.youku.com/v_show/id_XNDA1OTc0OTQ5Mg==.html)
  * [解读电子商务法（三）电商行为规范](https://v.youku.com/v_show/id_XNDA4NzIyNjI4MA==.html)
  * [解读电子商务法（四）电商的法律关系](https://v.qq.com/x/page/e08443fc1cr.html)
  * [解读电子商务法（外传）电商挣钱的秘密](https://v.youku.com/v_show/id_XNDA4MTQ2Nzk4NA==.html)
  * [解读电子商务法（外传）电商模式](https://v.qq.com/x/page/j0844twjwr5.html)

* [程序员需要知道的法律常识](https://blog.csdn.net/a331685690/article/details/79917772)
* [白话法律42讲-为程序员打造的专属法律武器](https://time.geekbang.org/column/132)

### 严格遵守刑法253法条

我国刑法第253条之一规定：

> * 国家机关或者金融、电信、交通、教育、医疗等单位的工作人员，违反国家规定，将本单位在履行职责或者提供服务过程中获得的公民个人信息，出售或者非法提供给他人，情节严重的，处3年以下有期徒刑或者拘役，并处或者单处罚金。
> * 窃取或者以其他方法非法获取上述信息，情节严重的，依照前款的规定处罚。 
> * 单位犯前两款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照各该款的规定处罚。

最高人民法院、最高人民检察院关于执行《中华人民共和国刑法》确定罪名的补充规定（四）规定：触犯刑法第253条之一第1款之规定，构成“出售、非法提供公民个人信息罪”；触犯刑法第253条之一第2款之规定，构成“非法获取公民个人信息罪”

* [《非法获取公民个人信息罪》](https://baike.baidu.com/item/%E9%9D%9E%E6%B3%95%E8%8E%B7%E5%8F%96%E5%85%AC%E6%B0%91%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%E7%BD%AA)

### 避风港原则
“避风港”原则是指在发生著作权侵权案件时，当ISP（网络服务提供商）只提供空间服务，并不制作网页内容，如果ISP被告知侵权，则有删除的义务，否则就被视为侵权。如果侵权内容既不在ISP的服务器上存储，又没有被告知哪些内容应该删除，则ISP不承担侵权责任。 后来避风港原则也被应用在搜索引擎、网络存储、在线图书馆等方面。
* [《避风港原则》](https://baike.baidu.com/item/%E9%81%BF%E9%A3%8E%E6%B8%AF%E5%8E%9F%E5%88%99/588459?fr=aladdin)

# 架构师素质

* [《架构师画像》](http://hellojava.info/?p=430)
	* 业务理解和抽象能力
	* NB的代码能力
	* 全面：1. 在面对业务问题上，架构师脑海里是否会浮现出多种技术方案；2. 在做系统设计时是否考虑到了足够多的方方面面；3. 在做系统设计时是否考虑到了足够多的方方面面； 
	* 全局：是否考虑到了对上下游的系统的影响。
	* 权衡：权衡投入产出比；优先级和节奏控制；

* [《关于架构优化和设计，架构师必须知道的事情》](http://www.infoq.com/cn/articles/architecture-optimization-and-design-the-architect-must-know)
	* 要去考虑的细节：模块化、轻耦合、无共享架构；减少各个组件之前的依赖、注意服务之间依赖所有造成的链式失败及影响等。
	* 基础设施、配置、测试、开发、运维综合考虑。
	* 考虑人、团队、和组织的影响。 

* [《如何才能真正的提高自己，成为一名出色的架构师？》](https://www.zhihu.com/question/19841397) 

* [《架构师的必备素质和成长途径》](https://blog.csdn.net/sanbingyutuoniao123/article/details/54144129)
	* 素质：业务理解、技术广度、技术深度、丰富经验、沟通能力、动手能力、美学素养。
	* 成长路径：2年积累知识、4年积累技能和组内影响力、7年积累部门内影响力、7年以上积累跨部门影响力。 

* [《架构设计师—你在哪层楼？》](http://blog.51cto.com/frankfan/1248401)
	* 第一层的架构师看到的只是产品本身
	* 第二层的架构师不仅看到自己的产品，还看到了整体的方案
	* 第三层的架构师看到的是商业价值 

# 团队管理

TODO

## 招聘

# 资讯

## 行业资讯

* [36kr](http://36kr.com/)
* [Techweb](http://www.techweb.com.cn/)

## 公众号列表

TODO

## 博客

### 团队博客
* [阿里中间件博客](http://jm.taobao.org/)
* [美团点评技术团队博客](https://tech.meituan.com)

### 个人博客

* [阮一峰的网络日志](http://www.ruanyifeng.com/)
* [酷壳 - COOLSHELL-陈皓](https://coolshell.cn/)
* [hellojava-阿里毕玄](http://hellojava.info/)
* [Cm's Blog](http://cmsblogs.com/)
* [程序猿DD-翟永超-《Spring Cloud微服务实战》作者](http://blog.didispace.com/)
* [三太子敖丙](https://github.com/AobingJava/JavaFamily)

## 综合门户、社区

**国内：**

* [CSDN](http://csdn.net)
	 老牌技术社区、不必解释。
* [51cto.com](http://www.51cto.com/)
* [ITeye](http://www.iteye.com/)
	* 偏 Java 方向 
* [博客园](https://www.cnblogs.com)
* [ChinaUnix](http://www.chinaunix.net/)
	* 偏 Linux 方向 
* [开源中国社区](https://www.oschina.net/)
* [InfoQ](https://www.infoq.cn/)
* [深度开源](http://www.open-open.com/)
* [伯乐在线](http://www.jobbole.com/)
	* 涵盖 IT职场、Web前端、后端、移动端、数据库等方面内容，偏技术端。

* [ITPUB](http://www.itpub.net/)
* [腾讯云— 云+社区](https://cloud.tencent.com/developer/column)
* [阿里云— 云栖社区](https://yq.aliyun.com/)
* [IBM DeveloperWorks](https://www.ibm.com/developerworks/cn/)
* [开发者头条](https://toutiao.io/)
* [LinkedKeeper](http://www.linkedkeeper.com)

**国外：**

* [DZone](https://dzone.com)
* [Reddit](https://www.reddit.com)

## 问答、讨论类社区

* [segmentfault](https://segmentfault.com)
	* 问答+专栏 
* [知乎](https://www.zhihu.com/)
* [stackoverflow](https://stackoverflow.com/)

## 行业数据分析

* [艾瑞网](http://report.iresearch.cn/)
* [QUEST MOBILE](https://www.questmobile.com.cn)

* [国家数据](http://data.stats.gov.cn/)

* [TalkingData](http://www.talkingdata.com/)

## 专项网站

* 测试:
	* [领测国际](http://www.ltesting.net/) 
	* [测试窝](https://www.testwo.com/)
	* [TesterHome](https://testerhome.com)

* 运维:
  	* [运维派](http://www.yunweipai.com/) 
  	* [Abcdocker](https://www.abcdocker.com/)
  
* Java:
	* [ImportNew](http://www.importnew.com/)
		* 专注于 Java 技术分享
	* [HowToDoInJava](https://howtodoinjava.com/)
		* 英文博客
	
* 安全
	* [红黑联盟](https://www.2cto.com/) 
	* [FreeBuf](http://www.freebuf.com/)

* 大数据
	* [中国大数据](http://www.thebigdata.cn/) 

* 其他专题网站：
	* [InfoQ](http://www.infoq.com/cn/)
		* 偏重于基础架构、运维方向
	* [DockerInfo](http://www.dockerinfo.net/)
		* 专注于 Docker 应用及咨询、教程的网站
	* [Linux公社](https://www.linuxidc.com/)
		* Linux 主题社区

## 其他类

* [程序员技能图谱](https://github.com/TeamStuQ/skill-map)

## 推荐参考书


### 在线电子书

* [《深入理解Spring Cloud与微服务构建》](https://github.com/forezp/SpringCloudLearning)


* [《阿里技术参考图册-研发篇》](http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523849261680/AliTech101_RD.pdf)
* [《阿里技术参考图册-算法篇》](http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523848064814/AliTech101_Algorithms.pdf)

* [《2018美团点评技术年货（合辑）》70M](http://dpurl.cn/n/1lqcX)

* [InfoQ《架构师》月刊](http://www.infoq.com/cn/architect/)

* [《架构师之路》](https://www.w3cschool.cn/architectroad/)

### 纸质书

<b style="color:red">更多架构方面书籍参考:</b> [awesome-java-books](https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E6%9E%B6%E6%9E%84)

#### 开发方面

* 《阿里巴巴Java开发手册》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=BfL5CR)

#### 架构方面
* 《软件架构师的12项修炼：技术技能篇》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=rTlo0m)
* 《架构之美》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=1KECBZ) 
* 《分布式服务架构》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=hkzqtK) 
* 《聊聊架构》 [详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=A8Nd6Z) 
* 《云原生应用架构实践》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=D4WCpd) 
* 《亿级流量网站架构核心技术》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=Rdmd21)
* 《淘宝技术这十年》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=CoUdGG)
* 《企业IT架构转型之道-中台战略思想与架构实战》 [详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=BxS6eI) 

* 《高可用架构（第1卷）》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=BcjUwS) 

#### 技术管理方面
* 《CTO说》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=Gl3QAo) 
* 《技术管理之巅》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=MeloLt)
* 《网易一千零一夜：互联网产品项目管理实战》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=qPuqMg) 

#### 基础理论
* 《数学之美》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=0seUpO) 
* 《编程珠玑》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=I7jj9r) 

#### 工具方面
TODO

#### 大数据方面

# 技术资源

## 开源资源
* [github](https://github.com)

* [Apache 软件基金会](https://www.apache.org/index.html)

## 手册、文档、教程

**国内：**
* [W3Cschool](http://w3cschool.cn) 
* [Runoob.com](http://www.runoob.com/)
	* HTML 、 CSS、XML、Java、Python、PHP、设计模式等入门手册。

* [Love2.io](https://love2.io/)
	* 很多很多中文在线电子书，是一个全新的开源技术文档分享平台。
* [gitbook.cn](http://gitbook.cn/)
	* 付费电子书。 
* [ApacheCN](http://www.apachecn.org/)
	* AI、大数据方面系列中文文档。

**国外：**

* [Quick Code](http://www.quickcode.co/)
	* 免费在线技术教程。
* [gitbook.com](http://gitbook.com)
	* 有部分中文电子书。
* [Cheatography](https://www.cheatography.com/)
	* Cheat Sheets 大全，单页文档网站。
* [Tutorialspoint](https://www.tutorialspoint.com/index.htm)
	* 知名教程网站，提供Java、Python、JS、SQL、大数据等高质量入门教程。
* [LeetCode](https://leetcode.com/problemset/all/)
	* 知名题库网站，提供Java、Python、C#、C++、算法、SQL、等高质量各程度题库和解决办法。

## 在线课堂

* [学徒无忧](http://www.xuetuwuyou.com/)
* [极客时间](https://time.geekbang.org/)
* [segmentfault](https://segmentfault.com/lives)
* [斯达克学院](https://new.stuq.org/course/explore)
* [牛客网](http://nowcoder.com)
* [极客学院](https://www.jikexueyuan.com/)
* [51CTO学院](http://edu.51cto.com/)

## 会议、活动

* [QCon](http://www.infoq.com/cn/qcon/)
* [ArchSummit](https://archsummit.com)
* [GITC全球互联网技术大会](http://www.thegitc.com/)

**活动发布平台:** 
* [活动行](http://www.huodongxing.com/)

## 常用APP

* [极客时间](https://time.geekbang.org)
* [得到](https://www.igetget.com)

## 找工作
* [Boss直聘](https://www.zhipin.com)
* [拉勾网](https://www.lagou.com)
* [猎聘](https://www.liepin.com)
* [100Offer](https://cn.100offer.com/)

## 工具

* [极客搜索](https://s.geekbang.org/)
	* 技术文章搜索引擎。

## 代码托管

* [Coding](https://coding.net)
* [码云](https://gitee.com/)

## 文件服务
* 七牛
* 又拍云

## 综合云服务商
* 阿里云
* [腾讯云](https://cloud.tencent.com/redirect.php?redirect=1012&cps_key=c2665015d90871c0cb20fef91b7afc3c)
* 百度云
* 新浪云
* 金山云
* [亚马逊云(AWS)](https://amazonaws-china.com/cn/)
* [谷歌云](https://cloud.google.com/?hl=zh-cn)
* [微软云](https://azure.microsoft.com/zh-cn/)

### VPS
* [Linode](http://linode.com)
* [DigitalOcean](https://www.digitalocean.com)
* [Vultr](https://www.vultr.com/)